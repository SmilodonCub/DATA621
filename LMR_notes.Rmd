---
title: 'Linear Models with `R`'
subtitle: 'by Julian Faraway'
author: 'notes by Bonnie Cooper'
output:
  rmdformats::downcute
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The following are notes from readings in ['Linear Models with `R`'](https://www.routledge.com/Linear-Models-with-R/Faraway/p/book/9781439887332) by Julian Faraway for the course DATA621, 'Business Analystics and Data Mining' as part of the [Masters of Science in Data Science program at CUNY SPS](https://sps.cuny.edu/academics/graduate/master-science-data-science-ms).

`R` libraries used:
```{r message=FALSE}
library( faraway )
library( dplyr )
library( ggplot2 )
library( gridExtra )
library( tidyverse )
library( HistData )
library( broom )
library( gclus )
library( asbio )
library( retistruct )
library( Matching )
library( MASS )
library( ellipse )
library( lmtest )
library( splines )
library( Amelia )
library( simex )
library( ggcorrplot )
library( leaps )
library( pls )
library( lars )
```

## Introduction
*"The formulation of a problem is often more essential than its solution"*

**Formulate the Problem Correctly**  

* Understand the Physical Background
* Understand the Objective
* Make sure you know what the client wants
* Put the Problem into Statistical Terms
  + observational or experimental data?
  + Is there Nonresponse?
  + Are there Missing Values?
  + How are the Data Coded?
  + What are the Units of Measurement?
  + Beware of data entry errors and other forms of data corruption
  
  
### Initial Data Analysis  
Critical to do an initial exploration to get the feel for the data. summary statistics. basic visualizations. inspect quality of the data...

look at some practice data:
```{r}
data( pima )
head( pima )
```
```{r}
summary( pima )
```

Not all missing values are `NA`. the minimum for `diastolic` is $0$. However, that's not a realistic value for a living person. Therefore, it is more likely that this is a missing value. Look closer at `diastolic`:
```{r}
sort( pima$diastolic )[1:100]
```
clean these values up for `diastolic` and the other similar numeric variables
```{r}
pima_NA <- pima %>%
  mutate( diastolic =  na_if( diastolic, 0 ),
             glucose = na_if( glucose, 0 ),
             triceps = na_if( triceps, 0 ),
             insulin = na_if( insulin, 0 ),
             bmi = na_if( bmi, 0 ) ) 
glimpse( pima_NA )
```
change the `test` feature to a categorical with descriptive labels:
```{r}
pima_NA$test <- factor( pima_NA$test )
levels( pima_NA$test ) <- c( 'negative', 'positive' )
summary( pima_NA$test )
```
Do some basic visualization of some features:
```{r}
par(mfrow=c(1,3))
pimahist <- hist( pima_NA$diastolic, xlab='Diastolic',main='' )
pimadens <- plot( density( pima_NA$diastolic, na.rm=TRUE ), main="" )
pimasort <- plot( sort( pima_NA$diastolic ), ylab = 'Sorted Diastolic' )
```

Now try again with ggplot:
```{r}
pimahist <- ggplot( pima_NA, aes( x = diastolic ) ) +
  geom_histogram()
pimadens <- ggplot( pima_NA, aes( x = diastolic ) ) +
  geom_density()
sdiastolic <- sort( pima_NA$diastolic )
pima_sort <- data.frame( 'sorted' = sdiastolic )
pimasort <- ggplot( pima_sort, aes( y = sorted, x = 1:length( sdiastolic ) ) ) +
  geom_point()

grid.arrange( pimahist, pimadens, pimasort, ncol = 3 )
```

Visualize some bivariate data
```{r}
p1 <- ggplot( pima_NA, aes( x = diastolic, y = diabetes ) ) +
  geom_point()

p2 <- ggplot( pima_NA, aes( x = test, y = diabetes ) ) +
  geom_boxplot()

grid.arrange( p1, p2, ncol = 2 )
```

`ggplot2` is a handy library that is more flexible when visualizing complex dataframes. For instance: controlling color/shape/fill by another variables, or creating faceted plots:
```{r}
#bisambiguating a factor variable:
p1 <- ggplot( pima, aes( x = diastolic, y = diabetes, color = factor( test ) ) ) +
  geom_point() +
  theme( legend.position = 'top',
         legend.direction = 'horizontal' )
p2 <- ggplot( pima, aes( x = diastolic, y = diabetes ) ) +
  geom_point( size = 1 ) +
  facet_grid( ~ factor( test ) )

grid.arrange(p1, p2, ncol=2,top="Disambiguating a factor variable")
```
**On Visualizations**: Good graphics are vital in data analysis. They help you avoid mistakes and suggest the form of the modeling to come. They are also important in communicating your analysis to others. Many in your audience or readership will focus on the graphs. This is your best opportunity to get your message over clearly and without misunderstanding. In some cases, the graphics can be so convincing that the formal analysis becomes just a confirmation of what has already been seen

### When to use Linear Modeling
**Linear Modeling** is used for explaining or modeling the relationship between a response/outcome/output variable and one or more predictor/input/explanatory variable(s).  
**Simple Regression**: modeling an outcome variable with just 1 explanatory variable.  
**Mulitple/Multivariate Regression**: modeling an outcome variable with more than 1 explanatory varaible.  

**Regression Objectives**  

* Prediction of future or unseen responses given specified values of the predictors
* Assessment of an effect, or relationship between, explanatory variables and the response

### History of Regression
describing the [libration of the moon](https://www.google.com/books/edition/The_History_of_Statistics/M7yvkERHIIMC?hl=en&gbpv=1&dq=stigler+1986&pg=PA1&printsec=frontcover):
```{r}
data( manilius )
glimpse( manilius )
```
The data are divided into three groups based on similarity. Next, compute the sum of the three coefficients by group.

```{r}
moon3 <- manilius %>%
  group_by( group ) %>%
  summarise( arc_sum = sum( arc ),
             sin_sum = sum( sinang ),
             cos_sum = sum( cosang ) )
moon3
```
The result are 3 linear equations with three unknowns each to solve
```{r}
solve( cbind( 9, moon3$sin_sum, moon3$cos_sum ), moon3$arc_sum )
```
Observe how similar the results are if we fit a linear regression to the original data:
```{r}
mod <- lm( arc ~ sinang + cosang, manilius )
summary( mod )
```
The word regression derives from a term of Sir Francis Galton's: *regression to mediocrity*  
**Important**: regression to mediocrity refers to a particular statistical finding and is quite a different concept to that of regression.  
Sir Francis Galton found that outcomes have a tendency towards the mean of the data using the heights of parents and their offspring. That is, tall parents are more likely to have a child shorter than they are and short parents are more likely to have a child taller than they are.  
Here we explore this data:  
```{r}
data( GaltonFamilies )
ggplot( GaltonFamilies, aes( x = midparentHeight,
                             y = childHeight ) ) +
  geom_point( size = 3 )
```
find the linear regression line the best fits the distribution
```{r}
mod <- lm( childHeight ~ midparentHeight, GaltonFamilies )
coef( mod )
```
```{r}
ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" )
```
Let's add the line that describes a relation where parents have children the same height as they are...
```{r}
ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" ) +
  geom_line( aes( y = midparentHeight ), color = 'red' )
```

Now suppose children height is fully correlated to thier parents. We can use the following equation:
$$\frac{y-\bar{y}}{SD_y} = r\frac{x-\bar{x}}{SD_x}$$
where the correlation, $r = 1$ to find the coefficients of a line describing this:
```{r}
beta <- with( GaltonFamilies,
                sd( childHeight )/ sd( midparentHeight ) )
alpha <- with( GaltonFamilies,
               mean( childHeight ) - 
                 beta * mean( midparentHeight ) )

ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" ) +
  geom_line( aes( y = midparentHeight ), color = 'red' ) +
  geom_abline(data=GaltonFamilies, aes(slope=beta, intercept=alpha ), color='green' )
```

**Regression to the Mean**: We can see that a child of tall parents is predicted by the least squares line to have a height which is above average but not quite as tall as the parents as
the green line would have you believe. Similarly children of below average height parents are predicted to have a height which is still below average but not quite as short as the parents. This is why Galton used the phrase “regression to mediocrity” and the phenomenon is sometimes called the regression effect.

### Recommended Exercises:
**1.1** The dataset `teengamb` concerns a study of teenage gambling in Britain. Make a numerical and graphical summary of the data, commenting on any features that you find interesting. Limit the output you present to a quantity that a busy reader would find sufficient to get a basic understanding of the data.

The `teengamb` dataset:
```{r}
data( teengamb )
glimpse( teengamb )
```
```{r}
teengamb_clean <- teengamb %>%
  mutate( sex = factor( sex ),
          status = factor( status ) )
summary( teengamb_clean )
```
The numerical summary shows the distribution of subjects in each group for the categorical variables `sex` and `status` as well as the mode/spread of the numerical features: `income` (lbs/wk), `verbal`, and `gamble` (annual).

and now to visualize the data:
```{r}
#visulize the numeric features by group features
si <- ggplot( teengamb_clean, aes( x = sex, y = income, fill = sex ) ) +
  geom_boxplot()
sv <- ggplot( teengamb_clean, aes( x = sex, y = verbal, fill = sex ) ) +
  geom_boxplot()
sg <- ggplot( teengamb_clean, aes( x = sex, y = gamble, fill = sex ) ) +
  geom_boxplot()

grid.arrange( si, sv, sg, ncol = 3 )

sti <- ggplot( teengamb_clean, aes( x = status, y = income, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")
stv <- ggplot( teengamb_clean, aes( x = status, y = verbal, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")
stg <- ggplot( teengamb_clean, aes( x = status, y = gamble, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")

grid.arrange( sti, stv, stg, ncol = 3 )
```
For `sex`, both genders have a very similar distribution of `income` and `verbal` scores. However, one gender has a very different distribution for the annual gambling expenditure.

There appears to be a linear relationship between `verbal` scores and `status` although for other features, the relationship is less clear. However, without knowing the meaning behind the `status` designations, it is difficult to tell.

Look at how some variable covary:
```{r}
ggplot( teengamb_clean, aes( y = gamble, x = income, color = sex ) ) + geom_point( size = 3 ) +
  geom_smooth(method = "lm", alpha = .15, aes(fill = sex))
```
If we plot the amount gambled against weekly income we see two very different trends for the different genders. Males (0) increase their gambling as a function of their weekly income whereas females (1), do not tend to gamble nor show the trend of increasing gambling with increasing income.

Let's take a look at the coefficients for these regression lines:
```{r}
teengamb_clean %>% group_by( sex ) %>%
  do( gambling = broom::tidy( lm( gamble ~ income, data = .))) %>% 
  unnest( gambling )
```
for every GBP increase in weekly income, a male British teen gambles 6.5GBP more annually. However, there is only a negligible increase for females of 0.17.


**1.3** The dataset `prostate` is from a study on 97 men with prostate cancer who were due to receive a radical prostatectomy. Make a numerical and graphical summary of the data as in the first question.

```{r}
data( prostate, package = 'faraway' )
glimpse( prostate )
```
let's learn what the variables are before proceeding:  

* lcavol -> log(cancer volume)
* lweight -> log(prostate weight)
* age -> age (years)
* lbph -> log(benign prostatic hyperplasia amount)
* svi -> seminal vesicle invasion
* lcp -> log(capsular penetration)
* gleason -> Gleason score
* pgg45 -> percentage Gleason scores 4 or 5
* lpsa -> log(prostate specific antigen)

observe summaries of each feature:
```{r}
# svi appears to be binary, so make that adjust:
prostate_clean <- prostate %>%
  mutate( svi = factor( svi ) )
summary( prostate_clean )
```
generate a matrix plot ordered by degree of correlation:
```{r}
dta <- prostate_clean %>%
  dplyr::select( -c( svi, gleason ) )
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```
we observe a number of cross-correlations that might need attention for further analysis. For example, `lbph`, or the amount of benign prostatic hyperplasia amount is highly correlated with the weight of the prostate, `lweight`.

the Gleason Score assesses the severity of prostate cancer: A Gleason score of 6 is low grade, 7 is intermediate grade, and a score of 8 to 10 is high grade cancer.

We might be interested in using these features to find out what is predictive of `gleason`. How predictive are certain data features correlate with the Gleason Score?

**1.4** The dataset `sat` comes from a study entitled “Getting What You Pay For: The Debate Over Equity in Public School Expenditures.” Make a numerical and graphical summary of the data as in the first question.

```{r}
data( sat )
glimpse( sat )
```
observe the general properties of each variable
```{r}
summary( sat )
```
generate a matrix plot ordered by degree of correlation:
```{r}
dta <- sat
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```

Plot the trends for sat scores as a function of expenditure:
```{r}
sat_scores <- sat %>%
  dplyr::select( expend, verbal, math ) %>%
  pivot_longer( cols = c( verbal, math ), 
                names_to = 'testcat',
                values_to = 'score' )
ggplot( sat_scores, aes( x = expend, y = score, color = testcat ) ) +
  geom_point( size = 2 ) +
  ylab( 'score' )
```
This plot suggests that there is a negative relationship between the expenditures of a state and the average sat scores for both math and verbal.

```{r}
sat_scores %>% group_by( testcat ) %>%
  do( exscor = broom::tidy( lm( score ~ expend, data = .))) %>% 
  unnest( exscor )
```

look at the cummulative scores
```{r}
sat_total_lm <- sat %>%
  do( totalsat = broom::tidy( lm( total ~ expend, data = . ) ) ) %>%
  unnest( totalsat )
sat_total_lm
```
Although the negative relationship is significant, this does not take into account an important confounding variable: the percentage of students that takes the exam:

```{r}
ggplot( sat, aes( y = total, x = takers ) ) +
  geom_point( size = 2 )
```
Perform a multiple linear regression that includes the percentage of people taking the sat
```{r}
satmod <- lm( total ~ expend + takers, sat )
summary( satmod )
```
There is a dramatic improvement in the model fit when percentage of sat test takers is included. However, there is definitely room for improving on this model. For instance, the 'U' shaped envelope of the relationship between total score and percent test takers hints at a nonlinearity. Additionally, there are more data features in the set that could be explored.

**1.5** The dataset 'divusa' contains data on divorces in the United States from 1920 to 1996. Make a numerical and graphical summary of the data as in the first question.

```{r}
data( divusa )
glimpse( divusa )
```
inspect the summary stats:
```{r}
summary( divusa )
```
Use `facet_wrap()` to look at how each of the features varies with time (`year`):
```{r}
divusa_long <- divusa %>%
  pivot_longer( cols = c( divorce, unemployed, femlab, marriage, birth, military ), names_to = 'cat', values_to = 'val' )
ggplot( aes( x = year, y = val ), data = divusa_long ) +
  geom_line() +
  #geom_point() +
  facet_wrap( ~ cat )
```
There are a few trends we see that occur over time:  

* the increase in percentage of women in the workplace
* spikes in military/femlab/divorce/marriage coinciding with WW2
* a peak in unemployment corresponding with the great depression

and now to view pairwise comparisons:
```{r}
dta <- divusa
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```
There are several relationships that look interesting to explore further:  

* the percentage of women in the workplace has a positive correlation with the divorce rate and a negative relationship with the marriage rate.
* the birth rate has a similar relationship: positively correlated with marriage and negatively correlated to divorce
* Not immediately clear from the previous figure: we see that divorce has a positive correlation with time whereas marriage is negative

## Estimation

### Linear Model
suppose we want to model a response property $Y$ by three feature variables $X_1$ $X_2$ and $X_3$. A general form to represent that is given:
$$Y = f(X_1,X_2,X_3) + \epsilon$$
typically, we won't ever know the true $f$. For linear models, we make the assumption that parameters enter linearly to predict the response:
$$Y = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_3 + \epsilon$$
Linear models seem restrictive, but predictors can be transformed and combined such that linear models can be applied. Linear model implies simplicity, however, in practice linear models and the data they describe may in fact be quite complex.  
Where do linear models come from?  

* Physical Theory may suggest a model (Hooke's Law)
* Experience with past data
* No prior data exists (linear model used as a starting point)

*A good model is like a map that guides us to our destination*

### Estimating \beta
We would like to choose $\beta$ such that the systematic component of our model explains as much of the response as possible. where:

| Data =        | Systemic Structure | + | Random Variation |
|---------------|--------------------|---|------------------|
| n dimentions= | p dimensions       | + | (n-p) dimensions |

The difference between the actual response and the predicted response = the residual. 
The conceptual purpose of the linear model is to represent as accurately as possible, some data that is complex with n-dimensions with something that is comparatively simple, a model with just 'p' terms/coefficients.

### Least Squares Estimation
The random variation in the residuals lies in the n-p dimensional space; the aim of fitting a model is the minimize the residuals.  
n-p = *degrees of freedom*  
RSS = Residual Sum of Squares  
estimate of $\sigma^2$: $\hat{\sigma}^2 = \frac{RSS}{n-p}$

### An Example from the Galapagos
```{r}
data( gala )
glimpse( gala )
```
fit a linear model using `lm()`
```{r}
gala_mod <- lm( Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data = gala )
gala_mod_sum <- summary( gala_mod )
gala_mod_sum 
```
the abridged output alternative from the `faraway` library:
```{r}
sumary( gala_mod )
```

Let's directly calculate some quantities of interest:
```{r}
#extract the feature matrix and the response variable:
fmat <- model.matrix( ~ Area + Elevation + Nearest + Scruz + Adjacent, gala )
r <- gala$Species
```
construct $(X^TX)^{-1}$:
```{r}
xtxi <- solve( t( fmat ) %*% fmat )
```
get $\hat{\beta}$ by calculating $(X^TX)^{-1}X^Ty$:
```{r}
xtxi %*% t( fmat ) %*% r
```
A more efficient and accurate way to get $\hat{\beta}$:
```{r}
solve( crossprod( fmat, fmat ), crossprod( fmat, r ) )
```
compare with the `lm()` results:
```{r}
sumary( gala_mod )
```
We can extract a lot of information from the lm structure:
```{r}
residuals( gala_mod ) #extract the residuals
fitted( gala_mod ) #extract the model predictions
df.residual( gala_mod ) #extract the degrees of freedom
deviance( gala_mod ) #gives the RSS
coef( gala_mod ) #returns the coefficient estimates
```

estimate $\sigma$:
```{r}
sqrt( deviance( gala_mod ) / df.residual( gala_mod ) )
gala_mod_sum$sigma
```
compute the standard error for the coefficients
```{r}
xtxi <- gala_mod_sum$cov.unscaled
SE <- sqrt( diag( xtxi ) ) * gala_mod_sum$sigma
SE
```
or extract the SE
```{r}
gala_mod_sum$coef[,2]
```
There are great reasons to use Least Squares:  

* It makes sense geometrically (makes an orthogonal projection onto model space)
* If the errors are independent and identically normally distributed, it estimates the maximum likelihood
* The Gause-Markov rule states that $\hat{\beta}$ is the best linear unbiased estimate

However, there are some situations where Least Squares might not be the best:

* When errors are correlated of have unequal variance
* When the error distribution is long-tailed
* When the predictors are collinear

### Goodness of Fit
a measure of how well the model fits the data.  
*$R^2$* or the **coefficient of determination** or the **percentage of variance explained**:
$$R^2 = 1 - \frac{\mbox{RSS}}{\mbox{Total SS(Corrected for Mean)}} = \mbox{cor}^2 (\hat{y},y)$$
It is a mistake to rely on $R^2$ as the sole measure of goodness of fit.
```{r}
op <- par(mfrow=c(1,4),mar=c (0,0,2,3), oma = c(5, 4.2, 0, 0))
with(anscombe, plot(x1, y1, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x1, y1),2)))))); abline(3,0.5) 
with(anscombe, plot(x2, y2, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x2, y2),2)))))); abline(3,0.5) 
with(anscombe, plot(x3, y3, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x3, y3),2)))))); abline(3,0.5) 
with(anscombe, plot(x4, y4, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x4, y4),2)))))); abline(3,0.5) 
mtext(expression(italic(y[1])),side=1, outer = TRUE, line = 3)
mtext(expression(italic(y[2])),side=2, outer = TRUE, line = 2.6)
mtext("(a)",side=3, at = -42, line = .5)
mtext("(b)",side=3, at = -26, line = .5)
mtext("(c)",side=3, at = -10.3, line = .5)
mtext("(d)",side=3, at = 5.5, line = .5)
par(op)
# }
```
All 4 of these distributions result in the same lm slope with the same $R^2$ value.

$\hat{\sigma}$ is another measure returned by the `lm()` summary that is in the same units as the response variable.

### Identifiability
Unidentifiability will occur when $X$ is not of full rank. e.g. columns that are linear combinations of one another.

### Orthogonality
```{r}
data( odor )
glimpse( odor )
```
compute the covariance:
```{r}
cov( odor[,-1] )
```
```{r}
odor_mod <- lm( odor ~ temp + gas + pack, odor )
summary( odor_mod, cor = T )
```
The Correlation Coefs are 0.  
These feature variables are entirely independent

### Exercises

#### 2.4
The dataset `prostate` comes from a study on 97 men with prostate cancer who were due to receive a radical prostatectomy. Fit a model with lpsa as the response and lcavol as the predictor. Record the residual standard error and the $R^2$ . Now add lweight, svi, lbph, age, lcp, pgg45 and gleason to the model one at a time. For each model record the residual standard error and the $R^2$. Plot the trends in these two statistics.

```{r}
data( prostate, package = 'faraway' )
glimpse( prostate )
```
fit model and keep track of residual standard error and $R^3$:
```{r}
formula <- ''
formulas <- c()
res_std_err <- c()
r_sqrd <- c()
feature_order <- c( 'lcavol', 'lweight', 'svi', 'lbph', 'age', 'lcp', 'pgg45', 'gleason' )
for (i in 1:length( feature_order )) {
  if (i == 1) {
    formula <- paste0('lpsa', " ~ ", feature_order[i] )
  }
  else {
    formula <- paste0(formula, " + ", feature_order[i] )
  }
  mod_sum <-  summary( lm( formula, data = prostate ) )
  res_std_err[[i]] <- mod_sum$sigma
  r_sqrd[[i]] <- mod_sum$r.squared
  #print( formula )
}

mods_df <- data.frame( 'n_terms' = seq( 1,8 ),
                       'sigma' = unlist(res_std_err, recursive = FALSE),
                       'r_sqrd' = unlist(r_sqrd, recursive = FALSE) )
glimpse( mods_df )
```

visualize the trends of the summary statistics:
```{r}
sigma_plot <- ggplot( mods_df, aes( x = n_terms, y = sigma ) ) +
  geom_point(fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_line() +
  xlab( 'Number of features added to lm()' ) +
  ylab( 'sigma' ) +
  theme_classic() 

r_sqrd_plot <- ggplot( mods_df, aes( x = n_terms, y = r_sqrd ) ) +
  geom_point(fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_line() +
  xlab( 'Number of features added to lm()' ) +
  ylab( 'R^2' ) +
  theme_classic() 

grid.arrange( sigma_plot, r_sqrd_plot, ncol = 2 )
```


#### 2.5
Using the prostate data, plot lpsa against lcavol. Fit the regressions of lpsa on lcavol and lcavol on lpsa. Display both regression lines on the plot. At what point do the two lines intersect?

```{r}
m <- lm(lcavol ~ lpsa, prostate)
m2 <- lm(lpsa ~ lcavol, prostate)

plot1 <- ggplot(prostate, aes(lcavol, lpsa)) +
  geom_point(fill = NA, shape = 21, alpha = 0.5, size = 3) +
  geom_line(aes(x = predict(m), color = "lcavol ~ lpsa")) +
  geom_line(aes(y = predict(m2), color = "lpsa ~ lcavol")) +
  theme_classic() 
plot1
```
find the intersection of the two lines:
```{r}
m_aug <- augment( m )
m2_aug <- augment( m2 )
P3 <- c( m2_aug$lcavol[1], m2_aug$.fitted[1] )
P4 <- c( m2_aug$lcavol[length( m2_aug$lcavol )], m2_aug$.fitted[length( m2_aug$lcavol )] )
P1 <- c( m_aug$.fitted[1], m_aug$lpsa[1] )
P2 <- c( m_aug$.fitted[length( m_aug$lcavol )], m_aug$lpsa[length( m_aug$lcavol )] )
intersect <- line.line.intersection(P1, P2, P3, P4, interior.only = TRUE)
int_df <- data.frame( 'X' = intersect[1], 'Y' = intersect[2] )
int_df
```
visually confirm the intersection
```{r}
coords <- paste( '(', round(int_df$X,2), ',', round(int_df$Y,2), ')' )
plot1 + annotate(geom="point", x=int_df$X, y=int_df$Y,
              color="red") +
  annotate(geom="text", x=2, y=2, label=coords,
              color="red")
  ggtitle( 'intersection of lm() model fits' )
```

## Inference

### Hypothesis Tests to Compare Models
**F-statistic**: A statistic used to evaluate the residuals for the model compared to the null hypothesis.  
$$F = \frac{ \frac{(RSS_{\omega}-RSS_{\Omega})}{p-q}}{\frac{ RSS_{\Omega}}{n-p}} \sim F_{p-q,n-p}$$
We would reject the null hypothesis if $F\gt F_{p-q,n-p}^{(\alpha)}$
Where p = num parameters in $\Omege$ and q is the num params in $\omega$. The degrees of freedom of a model at typically the number of observations - the number of parameters, so F can also be written as:
$$F = \frac{ \frac{(RSS_{\omega}-RSS_{\Omega})}{df_{\omega}-df_{\Omega}}}{\frac{ RSS_{\Omega}}{df_{\Omega}}}$$

#### Are any of the Feature Variables Useful in Predicting the Response?
We do not know whether all predictors are required to predict a response or just some. The F-statistic can help determine this.  

Demonstrate this by revisiting the data from the Galapagos:
```{r}
gala_mod_sum
```
model the Null Hypothesis and perform an ANOVA:
```{r}
gala_nullmod <- lm( Species ~ 1, gala )
anova( gala_nullmod, gala_mod )
```
Directly computing the F-stat & it's p-value:
```{r}
rss0 <- deviance( gala_nullmod )
rss <- deviance( gala_mod )
df0 <- df.residual( gala_nullmod )
df <- df.residual( gala_mod )
fstat <- ((rss0-rss)/(df0-df)/(rss/df))
fstat
1 - pf( fstat, df0-df, df )
```

#### Can 1 particular feature be dropped from a model?
Let $\Omega$ be the full model.  
Let $\omega$ be the full model - suspect feature.  
Test whether the feature can be dropped by looking at the F-statistic. 
The null hypothesis is that $H_0 : \beta_i = 0$

```{r}
gala_mod_noArea <- lm( Species ~ Elevation + Nearest + Scruz + Adjacent, gala )
anova( gala_mod_noArea, gala_mod )
```
The p-val of 0.3 indicates that the Null cannot be rejected

#### Testing a pair of predictors
Fit a model without the pair & build the F-test:
```{r}
gala_mod_noAreas <- lm( Species ~ Elevation + Nearest + Scruz, gala )
anova( gala_mod_noAreas, gala_mod )
```
Here, the F-test is statistically significant suggesting that we can reject the null hypothesis. The rejection suggests that there is a difference in the amount of residual error that is accounted for between the two models therefore, removing the pair of feature variables cannot be justified.  

#### Testing a Subspace  

* Can we combine two features? use the `I()`, or interaction function to test linear combinations of feature variables
* Can a feature be set to a particular values? use the `offset()` function

#### What can't we use an F-test to evaluate?  

* Non-linear relationships. ex: $H_0 : \beta_j \beta_k = 1$
* the null model needs to be in the feature subspace of the full model.  

### Permutation Tests: when you don't want to assume normality
**Permutation Test**: what is the chance that the F-test is larger than we observed? We could compute this exactly by computing the F-stat for all permutations of the response variable and see what proportion have greater F-tests.

```{r}
gala_mod_2 <- lm( Species ~ Nearest + Scruz, gala )
gala_mod_2_sum <- summary( gala_mod_2 )
gala_mod_2_sum$fstatistic
1 - pf( gala_mod_2_sum$fstatistic[1],
        gala_mod_2_sum$fstatistic[2],
        gala_mod_2_sum$fstatistic[3])
#anova( gala_mod_noAreas, gala_mod )
```
use the `sample()` function to repeat this 4000x
```{r}
nreps <- 4000
fstats <- numeric( nreps )
for (i in 1:nreps ) {
  lmsum <- summary( lm( sample( Species ) ~ Nearest + Scruz, gala ) )
  fstats[i] <- lmsum$fstat[1]
}

mean( fstats > gala_mod_2_sum$fstatistic[1] )
```

### Sampling
a finite population from which we draw a simple random sample that is our data.

### Confidence Intervals for $\beta$

consider our galapagos model:
```{r}
sumary( gala_mod )
```

construct 95% CI for $\beta_{area}$
```{r}
tdist <- qt( 0.975, 30-6 ) #t-dist w/ 30-6 degrees of freedom
c( -0.023938 - tdist * 0.022422, -0.023938 + tdist * 0.022422)
```
CIs have a duality with the 2-sided hypothesis tests: if the interval contains zero, this indicates that we cannot reject the null hypothesis. $\beta_{area}$'s CI contains 0, therefore we cannot reject the null hypothesis.

```{r}
c( -0.074805 - tdist * 0.0177, -0.074805 + tdist * 0.0177)
```
$\beta_{adjacent}$'s CI does not, so we can reject the null hypothesis.

We can quickly find the CI for all feature variables in the model:
```{r}
confint( gala_mod )
```

Confidence Regions:
```{r}
plot( ellipse( gala_mod, c( 2,6 ) ), type = 'l', ylim = c(-0.13,0 ) ) #Confidence Ellipse
points( coef( gala_mod )[2], coef( gala_mod )[6], pch=19 ) #least squares estimate
abline( v = confint( gala_mod)[2,], lty = 2 ) #confidence intervals
abline( h = confint( gala_mod)[6,], lty = 2 )
```
We can reject the null hypothesis because the origin does not lie within the ellipse

### Bootstrapped Confidence Intervals
F & t based CIs are convenient, however, they rely on the assumption of normality. Boostrapped CI's are good workaround.

#### Simulation
Sample the known distribution and compute the estimate. Repeat these steps multiple times and estimate the sampling distribution of $\hat{\beta}$ using the empirical distribution of the generated/simulated $\hat{\beta}$:  

* Generate $\epsilon$ from the known error distribution
* From $y = X\beta + \epsilon$ from the known $'beta$ and fixed $X$.
* Compute $\hat{\beta}$.

#### Bootstrap
Instead of sampling from the true (empirical) data, sample from observed data.  
Bootstrapping mirrors simulation, but works with the data on hand without making assumptions about it's distribution:  

* Generate $\epsilon^*$ by sampling with replacement from $\hat{\epsilon_1}, \ldots,\hat{\epsilon_n}$
* Form $y^* = X\hat{\beta} + \epsilon^*$
* Compute $\hat{\beta}^*$ from $(X,y^*)$

```{r}
num_boots <- 4000
coefmat <- matrix( NA, num_boots, 6 )
resids <- residuals( gala_mod )
preds <- fitted( gala_mod )

for ( i in 1:num_boots ) {
  booty <- preds + sample( resids, rep = TRUE )
  bmod <- update( gala_mod, booty ~ . )
  coefmat[ i, ] <- coef( bmod )
}

colnames( coefmat ) <- c( "Intercept", colnames( gala[, 3:7 ] ) )
coefdf <- data.frame( coefmat )
CIs <- apply( coefdf, 2, function( x ) quantile( x, c( 0.025, 0.975 ) ) )
CIs
```
let's remind ourselves of the CIs computed with normal distribution theory:
```{r}
confint( gala_mod )
```
the CIs are not identical but are comparable.  

Now take a look at some of the bootstrapped distributions and the CIs:
```{r}
CIs
pA <- ggplot( coefdf, aes( x = Area ) ) + geom_density() + 
  geom_vline( xintercept = c( CIs[ 1,2 ], CIs[ 2,2 ] ), lty = 2 )
pE <- ggplot( coefdf, aes( x = Elevation ) ) + geom_density() + 
  geom_vline( xintercept = c( CIs[ 1,3 ], CIs[ 2,3 ] ), lty = 2 )
pN <- ggplot( coefdf, aes( x = Nearest ) ) + geom_density() + 
  geom_vline( xintercept = c( CIs[ 1,4 ], CIs[ 2,4 ] ), lty = 2 )
pS <- ggplot( coefdf, aes( x = Scruz ) ) + geom_density() + 
  geom_vline( xintercept = c( CIs[ 1,5 ], CIs[ 2,5 ] ), lty = 2 )
pAd <- ggplot( coefdf, aes( x = Adjacent ) ) + geom_density() + 
  geom_vline( xintercept = c( CIs[ 1,6 ], CIs[ 2,6 ] ), lty = 2 )

grid.arrange( pA, pE, pN, pS, pAd )
```
The distributions are all roughly normal. However, this is not always the case


### Exercise 3.4
Using `sat` data:

a) Fit a model with total sat score as the response and expend, ratio and salary as predictors. Test the hypothesis that $\beta_{salary}$ = 0. Test the hypothesis that $\beta_{salary}$ = $\beta_{ratio}$ = $\beta_{expend}$ = 0. Do any of these predictors have an effect on the response?

```{r}
sat_sub <- sat %>% dplyr::select( c( total, expend, ratio, salary, takers ) )
dta <- sat_sub
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```

```{r}
sat_mod <- lm( total ~ expend + ratio + salary, data = sat )
sumary( sat_mod )
confint( sat_mod )
```
We cannot reject the null hypotheses as these predictors all include 0 within thier confidence intervals and do not have a statistically significant effect on the response.

b) Now add takers to the model. Test the hypothesis that $\beta_{takers}$ = 0. Compare this model to the previous one using an F-test. Demonstrate that the F-test and t-test here are equivalent.

```{r}
sat_mod2 <- lm( total ~ expend + ratio + salary + takers, data = sat )
sum2 <- sumary( sat_mod2 )
sum2
confint( sat_mod2)
```
We can reject the null hypothesis that $\beta_{takers} = 0$, because $\beta_{takers}$'s CI does not span 0.

```{r}
sat_anova <- anova( sat_mod, sat_mod2 )
sat_anova
```
The p-value indicates that we can reject the null hypothesis and conclude that the addition of `takers` to the model leads to a statistically significant difference in the models ability to describe the variance in the data. Additionally, we can see that the F-statistic from the anova is equivalent to the t-test for takers in the summary of the linear model:
```{r}
sat_anova$`Pr(>F)`[2] == sum2$coefficients[5,4]
```



## Prediction
Prediction is one of the main uses for regression models. However, a point estimate is not the end of the story. It is as important to consider the uncertainty of the estimate so that we may understand the range of expected outcomes. Projections are not useful without a realistic estimate of uncertainty because we need to make sensible plans for when events do not turn out as well as predicted. 

### Confidence Intervals for Prediction

* **Prediction of a Mean Response**: Confidence Interval
  + $\hat{y}_0 \pm t_{n-p}^{\frac{\alpha}{2}}\hat{\sigma} \sqrt{x_0^T(X^TX)^{-1}x_0}$
  + There is a 95% chance that the mean value falls within this CI
* **Prediction of a Future Observations**: Prediction Interval
  + $\hat{y}_0 \pm t_{n-p}^{\frac{\alpha}{2}}\hat{\sigma} \sqrt{1 + x_0^T(X^TX)^{-1}x_0}$
  + There is a 95% chance that the future value falls with in this PI
* **Extrapolation**: Predicting an estimate for values that lie outside of the given data range

### Example: Body Fat
load body fat data:
```{r}
data( fat )
#glimpse( fat )
fatmod <- lm( brozek ~ age + weight + height + 
                neck + chest + abdom + hip + thigh + 
                knee + ankle + biceps + forearm + 
                wrist, data = fat )
summary( fatmod )
```
Consider a 'typical' man (mean features).
```{r}
x <- model.matrix( fatmod )
x0 <- apply( x, 2, median )
x0
```

```{r}
fat_select <- fat %>%
  dplyr::select( c( age, weight, height, neck, chest, abdom, hip, thigh, knee, ankle, biceps, forearm, wrist ) )
meanMan <- colMeans( fat_select )
meanMan
```
if we are predicting the expected value and PI for an individual with mean features:
```{r}
predict( fatmod, newdata = data.frame( t( meanMan ) ), interval = 'prediction' )
```
if we are predicting the mean body fat for all men that have mean characteristics
```{r}
predict( fatmod, newdata = data.frame( t( meanMan ) ), interval = 'confidence' )
```

#### Extrapolation
the further away the values are from the original data, the more uncertainty there is in the estimations.  
Compare the intervals calculated below with those for the mean 'typical' body metrics:
```{r}
extremeFat <- apply( x, 2, function( x ) quantile( x, 0.95 ) )
predict( fatmod, newdata = data.frame( t( extremeFat ) ), interval = 'prediction' )
predict( fatmod, newdata = data.frame( t( extremeFat ) ), interval = 'confidence' )
```


### Autoregression

Consider the trends in this data on monthly airline passengers:

```{r}
data( airpass, package = 'faraway' )
AirlinePlot <- ggplot( airpass, aes( x = year, y = pass ) ) +
  geom_line() +
  ylab( 'Log(Passengers)' ) +
  theme_classic() +
  ggtitle( 'Airline Passengers', subtitle =  'with an obviously inappropriate linear regression fit')

AirlinePlot +   geom_smooth( method = 'lm' )
```

The linear fit above captures the increase in passengers over the years, but does nothing to capture the seasonal variation in the data.

**Autoregressive model**: the response depends on past values of the response. So, build into the model is a feature variable that describes a previous response. For example, it may be the case that we would like to predict the passengers for next month. We would like to know the expected change in ridership to predict next months ridership. Autoregressive 'lagged' variables can be incorporated into the model to describe the number of passengers from previous months:  

$$y_t = \beta_0 + \beta_1y_{t-1} + \beta_{12}y_{t-12} + \beta_{13}y_{t-13} + \epsilon_t $$

```{r}
lagdf <- embed( log( airpass$pass ), 14 )
colnames( lagdf ) <- c( 'y', paste0( 'lag',1:13 ) )
lagdf <- data.frame( lagdf )
#build our linear model:
armod <- lm( y ~ lag1 + lag12 + lag13, lagdf )
summary( armod )
```
visualize the autoregressive model fit:
```{r}
airpass_lag <- airpass[14:144,]
airpass_lag[ 'predict' ] <- exp( predict( armod ) )
AirlinePlot +
  geom_line( aes( x = year, y = predict, color = 'red' ), data = airpass_lag, show.legend = FALSE )
```

predicting future values:
use the last observation in the data as the lag one value:
```{r}
#last value of the data
last_row_df <- lagdf[ nrow( lagdf ), ]
# the current response variable ('y') will become lag1 and everything else shifts over 1:
new_data <- data.frame( lag1 = last_row_df$y, lag12 = last_row_df$lag11, lag13 = last_row_df$lag12 )
#prediction:
next_month_res <- predict( armod, newdata = new_data, interval = 'prediction' )

paste( 'The Autoregression Mod predicts', round( exp( next_month_res[1] ),0), 
       'passengers with a 95% confidence interval from', round( exp( next_month_res[2] ),0),
       'to', round( exp( next_month_res[3] ),0))
```

### What can go wrong with predictions?

* Bad Models: If it doesn't fit, don't apply it.
* Quantitative Extrapolation: We try to predict outcomes for cases with predictor values much different from what we saw in the data
* Qualitative Extrapolation: We try to predict outcomes for observations that come from different populations
* Overconfidence due to overfitting: data is not robust to new data
* Black swans: might not have enough data to properly describe the distribution


### Exercise 4.5
```{r}
#the full model
#fatmod
sumary( fatmod )
```
#short model
```{r}
fatmod_4 <- lm( brozek ~ age + weight + height + abdom, fat )
sumary( fatmod_4 )
```

a) Is it justifiable to use the smaller model?
```{r}
anova( fatmod, fatmod_4 )
```
There is a statistically significant difference between the amount of variance accounted for by the two models. The smaller model does not describe the data as well.

b) Compute a 95% prediction interval for median predictor values and compare to the results to the interval for the full model. Do the intervals differ by a practically important amount?
```{r}
medvals <- model.matrix( fatmod_4 )
medvals0 <- apply( medvals, 2, median )
#95% prediction interval for the median predictor values
predict( fatmod_4, newdata = data.frame( t( medvals0 ) ), interval = 'prediction' )
```
```{r}
#CI for the full model
predict( fatmod, newdata = data.frame( t( x0 ) ), interval = 'prediction' )
```
No, the intervals don't seem to differ by an appreciable amount. So, in moving to the smaller, simpler model, we don't seem to lose a lot of predictive power.

c) For the smaller model, examine all the observations from case numbers 25 to 50. Which two observations seem particularly anomalous?
```{r}
fatmod_4_aug <- augment( fatmod_4 )
fatmod_4_aug_sub <- fatmod_4_aug[25:50,]
#fatmod_4_aug_sub
ggplot( aes( x = .fitted ), data = fatmod_4_aug_sub ) + geom_dotplot()

#plot the model predictors for observation 25:50
fat %>%
  dplyr::select( c( age, weight, height, abdom ) ) %>%
  pivot_longer( cols = everything(), names_to = 'predictor', values_to = 'val' ) %>%
  ggplot( aes( x = predictor, y = val ) ) +
  geom_boxplot() +
  ggtitle( 'Observations 25:50: Predictive Features' )
```

```{r}
outliers <- function(dataframe){
dataframe %>%
    dplyr::select_if(is.numeric) %>% 
    map(~ boxplot.stats(.x)$out) 
}

fatsub <- fat[25:50,]
fat4 <- fatsub %>%
  dplyr::select( c( age, weight, height, abdom ) )
fat4out <- outliers( fat4 )
fat4out
```
from the output above, find the observation indices:
```{r}
#39, 42, 39
fat %>% filter( weight == c( 363.15 ) )
fat %>% filter( height == c( 29.5 ) )
fat %>% filter( weight == c( 148.1 ) )
```


d) Recompute the 95% prediction interval for median predictor values after these two anomalous cases have been excluded from the data. Did this make much difference to the outcome?

remove the two offending records: 39 & 42
```{r}
drop <- c( 39, 42 )
fat_remove2 <- fat[ -drop, ] 
fatmod_remove2_4 <- lm( brozek ~ age + weight + height + abdom, fat_remove2 )
medvals2 <- model.matrix( fatmod_remove2_4 )
medvals02 <- apply( medvals2, 2, median )
#95% prediction interval for the median predictor values
predict( fatmod_remove2_4, newdata = data.frame( t( medvals02 ) ), interval = 'prediction' )
predict( fatmod_4, newdata = data.frame( t( medvals0 ) ), interval = 'prediction' )
```
The CI narrows when the 2 outliers are removed, but is it significant?


## Explanation
The relationships between variables. can include causal conclusions, however these require more rigor.


### Simple Meaning
a simple interpretation of model coefficients: *unit increase in $x_1$ with the other predictors help constant will produce a change of $\hat{\beta_1}$ in the response variable $y$.* This is conceptually difficult: IRL there is no way to hold these variables constant to observe the model's effects and it is not likely that the model captures all contributing variables to the system. Furthermore, our model's explanation contains no notion of explanation.

### Establishing Causality  
causality is determined by experimentally manipulating a variable. Consider a drug trial test with a placebo group and a test group. We can describe the causal effect as:
$$\delta_i = y_i^{\mbox{test}}-y_y^{\mbox{control}}$$

### Designed Experiments
**Randomization is key to success** 

* Randomization is the only reliable way to make sure that the two groups are not unbalances in some way that 
favors either experimental groups.
* Randomization can be used to validate assumptions. (e.g. permutation tests used to test the significance of differences between groups)

On Generalization: The results of randomized experiments apply to the subjects of the experiment unless we can reasonably claim that these subjects are representative of a larger population.  
On Blocking: There may be ways that subjects differ from one another that are identifiable and that can be worked into the experiment. (e.g. Gender).

### Observstional Data
Cannot always collect data in a designed experiment.
Consider this dataset from the Democratic primary of 2008:
```{r}
data( newhamp )
glimpse( newhamp )
```
look at the difference in counts for Digital vs Hand cast ballots for Obama vs Clinton
```{r}
newhamp %>% group_by( votesys ) %>% 
  summarise( 'Obama' = sum( Obama ),
             'Clinton' = sum( Clinton ) ) %>%
  mutate( 'Obama_gt_percent' = (Obama - Clinton)/(Obama + Clinton)*100 )
```
We can see that for digital ballots, Clinton received ~6% more votes than Obama whereas for paper ballots Obama received about 8% more of the vote.  
Is this difference in votes based on voting system significant?  
Here we fit a linear model to proportion of votes for Obama ~ Hand voting.  
First we create a dummy variable for whether the record is for hand votes:
```{r}
newhamp_trt <- newhamp %>%
  mutate( treatment = case_when( votesys == 'H' ~ 1,
                                 votesys == 'D' ~ 0 ) )
newhamp_trt %>% do( tidy( lm( pObama ~ treatment, . ) ) )
```
The p-value for the treatment group suggests that there is a significant difference between the proportion of vote for Obama given the voting system used. However, were there other variables involved? Did the voting system have some causal effect on the outcome?  
In other words, is there a **confounding variable**?

```{r}
glimpse( newhamp )
newhamp_trt %>%
  do( tidy( lm( pObama ~ treatment + Dean + Kerry + povrate + white, . ) ) )
```
If we include other variables we see that our treatment variable is no longer a statistically significant towards predicting the proportion of votes for Obama.

### Matching
for matched pairs where two members of each pair are as alike as possible with respect to confounders.  
we will use the `Matching` library for this:
```{r}
set.seed( 123 )
matches <- GenMatch( newhamp_trt$treatment, newhamp_trt$Dean,
                     ties = FALSE, caliper = 0.05, pop.size = 1000 )
head( matches$matches[ ,1:2 ] )
```
The output above shows some of the pairs of one subject who voted by hand/paper vs one subject who voted digitally matched by thier propensity to vote have voted for Howard Dean in the previous election.

Show all the matches when plotted pObama ~ Dean
```{r}
plot( pObama ~ Dean, newhamp_trt, pch = treatment + 1 )
with( newhamp_trt, segments( Dean[ matches$matches[ ,1 ] ], 
                             pObama[ matches$matches[ ,1 ] ],
                             Dean[ matches$matches[ ,2 ] ],
                             pObama[ matches$matches[ ,2 ] ] ) )
```
From the figure above, we can see that the matches are reasonably well made for values of `Dean`  

Is there any indication of a bias for voting system within the matched pairs?  
Here we compute the difference between pairs
```{r}
pdiff <- newhamp_trt$pObama[ matches$matches[ ,1 ] ] - 
  newhamp_trt$pObama[ matches$matches[ ,2 ] ]
t.test( pdiff )
```
```{r}
plot( pdiff ~ newhamp_trt$Dean[ matches$matches[ ,1 ] ], 
      xlab = 'Dean', ylab = 'Hand - Digital' )
abline( h = 0 )
```
The matched pairs show no clear preference for hand vs digital voting.
The observed difference appears to be because voter inclined to pick Obama are also more likely to be present in hand voting wards.

### Covariate Adjustment, or Controlling for the covariate
Compare univariate and covariate outcomes for digital vs hand voting systems
```{r}
plot( pObama ~ Dean, newhamp_trt, pch = treatment + 1 )
abline( h = c( 0.353, 0.353 + 0.042 ), lty = 1:2 )
abline( 0.221, 0.5229 )
abline( 0.221 - 0.005, 0.5229, lty = 2 )
with( newhamp_trt, segments( Dean[ matches$matches[ ,1 ] ], 
                             pObama[ matches$matches[ ,1 ] ],
                             Dean[ matches$matches[ ,2 ] ],
                             pObama[ matches$matches[ ,2 ] ] ) )
```

### Qualitative Support for Causation

* Strenth - large effects
* Consistency - similar effect found in other studies
* Specificity - 
* Temporality - consistent direction of effect
* Gradient - linear relationship
* Plausibility - does it make sense
* Experiment

### Exercise 5.2

Use the `odor` dataset with odor as the response and temp as a predictor. Consider all possible models that also include all, some or none of the other two predictors. Report the coefficient for temperature, its standard error, t-statistic and p-value in
each case. Discuss what stays the same, what changes and why. Which model is best?

```{r}
data( odor )
glimpse( odor )
```

```{r}
dta <- odor
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```


```{r}
mod_stem <- 'odor ~ temp'
mod_set <- c(  '+ gas', '+ pack', '+ gas + pack' )
mod <- c()
mod_tempc <- c()
mod_se <- c()
mod_t <- c()
mod_p <- c()

for ( m in 1:length( mod_set ) ) {
  mod_str <- paste( mod_stem, mod_set[ m ] )
  mod[ m ] <- mod_str
  modfitsum <- summary( lm( mod_str, odor ) )
  mod_tempc[ m ] <- modfitsum$coefficients[ 2,1 ]
  mod_se[ m ] <- modfitsum$coefficients[ 2,2 ]
  mod_t[ m ] <- modfitsum$coefficients[ 2,3 ]
  mod_p[ m ] <- modfitsum$coefficients[ 2,4 ]
}

modfitsum
```


```{r}
odor_mods_df <- data.frame( 'mod' = mod, 
                            'temp_coef' = mod_tempc, 
                            'temp_se' = mod_se,
                            'temp_t' = mod_t,
                            'temp_pval' = mod_p )
glimpse( odor_mods_df )
```
Temperature does not have a statistically significant impact on the model's ability to describe the variability of the data. This does not change with the addition of other predictive features to the model as shown by the temperature feature's p-value. The standard error gets smaller with other terms included whereas the t-stat get larger in magnitude where both gas + pack are included as opposed to just one added.


## Categorical Predictors
Categorical features / predictors - qualitative as opposed to quantitative values

### A 2-level factor
```{r}
data( sexab )
glimpse( sexab )
by( sexab, sexab$csa, summary )
```

```{r}
boxp <- ggplot( sexab, aes( x = csa, y = ptsd ) ) +
  geom_boxplot()
scatp <- ggplot( sexab, aes( x = cpa, y = ptsd, color = csa ) ) +
  geom_point( show.legend = FALSE )

grid.arrange( boxp, scatp, ncol = 2 )
```
those in the abused group have higher rates as the not abused group.  
run a t-test to evaluate the statistical significance of this

```{r}
t.test( ptsd ~ csa, sexab, var.equal = TRUE )
```

use dummy variables to recode the 2-level feature variable
```{r}
sexab %>% mutate( dummy = case_when( csa == 'Abused' ~ 1,
                                     csa == 'NotAbused' ~ 0 ) ) %>%
  do( tidy( lm( ptsd ~ dummy, . ) ) )
```
```{r}
smod <- lm( ptsd ~ csa, sexab )
summary( smod )
```
the intercept ( 11.9 ) is the mean response for the reference level. the csaNotAbused estimate is the difference between levels  
if it is more intuitive the other way, can rereference the model:
```{r}
sexab$csa <- relevel( sexab$csa, ref = 'NotAbused' )
lmod <- lm( ptsd ~ csa, sexab )
summary( lmod )
```

### Factors and Quantitative Predictors
models that can express how a factor variable and a quantitative variable might be related to a response
consider modeling the sexual abuse model to include the physical abuse term `cpa`
```{r}
sexmod1 <- lm( ptsd ~ cpa + csa + cpa:csa, sexab )
summary( sexmod1 )
```

we can see that the interaction term is not significant, so we simplify the model
```{r}
sexmod2 <- lm( ptsd ~ cpa + csa, sexab )
summary( sexmod2 )
```
visualize the data with parallel regression lines
```{r}
group.colors <- c( Abused = 'red', NotAbused = 'blue')
ggplot( aes( x = cpa, y = ptsd, color = csa ), data = sexab ) +
  geom_point() +
  geom_abline( slope = sexmod2$coefficients[2], 
               intercept = sexmod2$coefficients[1], color = 'blue' ) +
  geom_abline( slope = sexmod2$coefficients[2], 
               intercept = sexmod2$coefficients[1] +
                 sexmod2$coefficients[3], color = 'red' ) +
  scale_color_manual(values=group.colors)
```
a simple check of the residuals for model diagnostics
```{r}
sexmod2_aug <- augment( sexmod2 )
ggplot( aes( x = .fitted, y = .resid, color = csa ), data = sexmod2_aug ) +
  geom_point() +
  scale_color_manual(values=group.colors)
```
We can see that there is no clear trend in the residuals and the variance of the two groups is approximately the same.

### Interpretation with Interaction Terms
```{r}
data( whiteside )
glimpse( whiteside )
```
```{r}
ggplot( aes( x = Temp, y = Gas ), data = whiteside ) +
  geom_point() + 
  facet_grid( ~ Insul ) +
  geom_smooth( method = 'lm' )
```

gas consumption is temperature dependent both before and after installing the insulation. However, less gas is used after installation.

Explore the interaction of temperature:
```{r}
whitehouse_mod <- lm( Gas ~ Temp*Insul, whiteside )
summary( whitehouse_mod )
```
From this model we can say that the average consumption before insulation at 0dC was 6.85. This makes interpretation complicated, because 0dC is at the low end extreme of the dataset. We can recenter the temperature predictor to account for this:
```{r}
whiteside$ctemp <- whiteside$Temp - mean( whiteside$Temp )
whiteside_mod <- lm( Gas ~ ctemp * Insul, whiteside )
summary( whiteside_mod )
```

Centering for mean Temp gives a more natural interpretation to the coefficients: The average consumption before insulation at the average temperature was 4.94 before insulation and 4.94-1.57= 3.37dC after installing the insulation. 

### Factors with more than 2 levels
Consider an experiment with 5 different treatment groups:
```{r}
data( fruitfly )
glimpse( fruitfly )
```
visualize longevity ~ thorax for all 5 groups
```{r}
ggplot( aes( x = thorax, y = longevity, color = activity ), data = fruitfly ) +
  geom_point()
```
plot as a facet-wrap:
```{r}
ggplot( aes( x = thorax, y = longevity, color = activity ), data = fruitfly ) +
  geom_point() +
  facet_wrap( ~ activity )
```
fit a linear model
```{r}
fruitfly_mod <- lm( longevity ~ thorax * activity, fruitfly )
sumary( fruitfly_mod )
```
```{r}
plot( fruitfly_mod )
```

```{r}
anova( fruitfly_mod )
```
We can see that the interaction term `thorac:activity` is not significant, so we can refit the model without this term:
```{r}
fruitfly_mod2 <- lm( longevity ~ thorax + activity, fruitfly )
```
But do we need both `thorax` and `activity`? Need to evaluate the model with just `thorax` first:
```{r}
drop1( fruitfly_mod2, test='F' )
```
The `drop1()` command tests each term relative to the full model.
```{r}
sumary( fruitfly_mod2 )
```
```{r}
plot( fruitfly_mod2 )
```

From the 'Residuals ~ Fitted` plot, we see some heteroscedasticity which can be addressed with a log transformation:
```{r}
fruitfly_mod3 <- lm( log( longevity ) ~ thorax + activity, fruitfly )
plot( fruitfly_mod3 )
```

```{r}
sumary( fruitfly_mod3 )
```
```{r}
exp( coef(fruitfly_mod3))
```
Daaaaammmmn. The high sexual activity group was found to have a shorter lifespan.

### Alternative Codings of Qualitative Predictors
consider a four-level factor coded with 3 dummy factors.

**Treatment Coding**
```{r}
contr.treatment( 4 )
```
**Helmert Coding**
```{r}
contr.helmert( 4 )
```

**Sum Coding**
```{r}
contr.sum( 4 )
```


### Exercise 14.2
Using the 'infmort' data, find a simple model for the infant mortality in terms of the other variables. Be alert for transformations and unusual points. Interpret your model by explaining what the regression parameter estimates mean.
```{r}
data( infmort )
glimpse( infmort )
```
```{r}
region <- ggplot( infmort, aes( x = region, y = mortality ) ) +
  geom_boxplot( )
oil <- ggplot( infmort, aes( x = oil, y = mortality ) ) +
  geom_boxplot( )
income <- ggplot( infmort, aes( x = log(income), y = mortality, color = region ) ) +
  geom_point( )
income2 <- ggplot( infmort, aes( x = log(income), y = mortality, color = oil ) ) +
  geom_point( )
grid.arrange( region, oil, income, income2, ncol = 2)
```


perform an AIC-based backward selection
```{r}
#make our full model to work backwards from:
infmort_full <- lm( mortality ~ log( income ) + oil + region, data = infmort )
summary( infmort_full )
```

we see from the plots that there are several high leverage point on the graphs. here we identify them & remove from the data
```{r}
HighLeverage <- cooks.distance(infmort_full) > (4/nrow(infmort))
infmort[ HighLeverage, ]
```
```{r}
#remove high leverage points
infmort_filt <- infmort[ !HighLeverage, ]
#refit full model:
infmort_full <- lm( mortality ~ log( income ) + oil + region, data = infmort_filt )
summary( infmort_full )
```


```{r}
infmort_backwards <- step( infmort_full, direction = 'backward', trace = 1 )
```
```{r}
summary( infmort_backwards )
```
I tried this before filtering the high leverage points and the backwards regression fits had dropped income. It looks like there were several high leverage countries with high income and oil exports that had high infant mortality rates. However, if these observations are filtered then income becomes important to the model. Additionally, if income is not modeled on a log scale, it is dropped when evaluating by AIC.  

Now trying to drop by F-test:
```{r}
drop1( infmort_full, test = 'F' )
```
```{r}
summary( infmort_full )
```
the intercept estimate gives the models estimate for mortality rate if the polity is an oil exporting in Africa. Given the same income and region, a non oil exporting country can expect an infant mortality rate ~-165 less. If income and oil exporting status is controlled for, regions in Europe, Asia & the Americas can expect a lower infant mortality rate than  Arican countries by the Estimates given (-86, -47, -83 respectively).  

## Diagnostics
Regression Diagnostics: there are several assumptions made when applying linear models, and diagnostic methods are used to determine if those assumptions are met before a model is deployed into the wild. Model building is an iterative process, and model diagnostics can often highlight aspects that need adjustment.    

potential issues with model assumptions:  

* **Error** - we assume that errors are independent and normally distributed
* **Model** - we have assumed that structurally the data supports a linear relationship
* **Unusual Observations** - it only takes a few extreme outliers to throw off a model

### Checking Error Assumptions
**Constant Variance**  
we need to check if variance of the residuals is relate to a feature of the model. the most useful diagnostic is to check the residuals as a function of $\hat{y}$. if all is well, you should see constant symmetrical variation in the distribution. **homoscedasticity**: when there is nonconstant variance.  

an example:
```{r}
data( savings )
savings_mod <- lm( sr ~ pop15 + pop75 + dpi + ddpi, data = savings )
savings_mod_aug <- augment( savings_mod )
#glimpse( savings_mod_aug )

p1 <- ggplot( savings_mod_aug, aes( x = .fitted, y = .resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  theme_classic()
p2 <- ggplot( savings_mod_aug, aes( x = .fitted, y = sqrt( abs( .resid ) ) ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  ylab( expression( sqrt( hat( epsilon )))) +
  theme_classic()
  
grid.arrange( p1, p2, ncol = 2 )
```
Both plots are satisfactory. Next a numeric test can next be applied to evaluate constant variance:
```{r}
sumary( lm( sqrt( abs( savings_mod_aug$.resid)) ~ savings_mod_aug$.fitted ) )
```

there is no obvious slope to the model summary output. the two visualizations look satisfactory, so we can assume that the assumption of constant variance for the residuals (error) is relatively constant.  

The following plot shows some simulated distributions to give examples of things to look out for in data
```{r}
par(mfrow=c(2,2))
n <- 500
for(i in 1:1) {x <- runif( n ) ; plot( x, rnorm( n ), title( 'Constant Variance' )) }
for(i in 1:1) {x <- runif( n ) ; plot( x, x*rnorm( n ), title( 'Strong NonConstant Variance' )) }
for(i in 1:1) {x <- runif( n ) ; plot( x, sqrt((x))*rnorm( n ), title( 'Mild NonConstant Variance' )) }
for(i in 1:1) {x <- runif( n ) ; plot( x, cos(x*pi/0.5)+rnorm( n,sd=1 ), title( 'NonLinearity' )) }
```

now to look at the residuals as a function of a few of the predictor variables:
```{r}
p1 <- ggplot( savings_mod_aug, aes( x = pop15, y = .resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'pop15' ) +
  theme_classic()
p2 <- ggplot( savings_mod_aug, aes( x = pop75, y = .resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'pop75' ) +
  theme_classic()
p3 <- ggplot( savings_mod_aug, aes( x = dpi, y = .resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'dpi' ) +  
  theme_classic()
p4 <- ggplot( savings_mod_aug, aes( x = ddpi, y = .resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'ddpi' ) +
  theme_classic()
  
grid.arrange( p1, p2, p3, p4, ncol = 2 )
```
The variance appear constant for `pop75`, but for `pop15` appears to have two groups

transformations can be applied to distributions to even out signs of non-constant variance
ex: refit the model with a square root transformation of `dpi` and `ddpi`. then look at the residual plots again:
```{r}
savings_mod2 <- lm( sr ~ pop15 + pop75 + sqrt(dpi) + sqrt(ddpi), data = savings )
savings_mod_aug2 <- augment( savings_mod2 )
glimpse( savings_mod_aug2 )
p1 <- ggplot( savings_mod_aug2, aes( x = pop15, y = .std.resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'pop15' ) +
  theme_classic()
p2 <- ggplot( savings_mod_aug2, aes( x = pop75, y = .std.resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'pop75' ) +
  theme_classic()
p3 <- ggplot( savings_mod_aug2, aes( x = `sqrt(dpi)`, y = .std.resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'dpi' ) +  
  theme_classic()
p4 <- ggplot( savings_mod_aug2, aes( x = `sqrt(ddpi)`, y = .std.resid ) ) + 
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  ggtitle( 'ddpi' ) +
  theme_classic()
  
grid.arrange( p1, p2, p3, p4, ncol = 2 )
```

That looks a little more even, but not satisfactory.

### Normality
Q-Q plots: compare the residuals to the '*ideal*' normal observations

```{r}
par(mfrow=c(1,2))

qqnorm( savings_mod_aug$.resid, ylab='Residuals',main='')
qqline( savings_mod_aug$.resid )

hist( savings_mod_aug$.resid, xlab = 'Residuals', main='' )
```
normal residuals should follow the line approximately. Here, the residuals look normal.

The Shapiro-Wilk test is a formal test for normality:
```{r}
shapiro.test( savings_mod_aug$.resid )
```
the $H_0$ is that the residuals are normal. Since the p-value is large, we do not reject the null hypothesis

### Correlated Errors
```{r}
data( globwarm, package = 'faraway')
gw_mod_aug <- augment( lm( nhtemp ~ wusa + jasper + westgreen + chesapeake + tornetrask + urals + mongolia + tasman, globwarm ) )
gw_mod_aug$year <- seq( 1856, 2000 )
ggplot( gw_mod_aug, aes( x = year, y = .resid ) ) +
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_abline( intercept = 0, slope = 0, color = 'red' ) +
  theme_classic()
```
that looks wild. you can see some clear trends for stretches of negative residuals and stretches of positive residuals.

next we check for serial correlation in the data
```{r}
n <- length( gw_mod_aug$.resid )
plot( tail( gw_mod_aug$.resid, n-1 ) ~ head( gw_mod_aug$.resid, n-1 ) )
abline( h=0, v=0, col = grey(0.75))
```
the positive correlation in the graph indicates positive serial correlation  

The Durbin-Watson test evaluates errors for correlation where the null hypothesis is that the errors are uncorrelated
```{r}
dwtest( nhtemp ~ wusa + jasper + westgreen + chesapeake + tornetrask + urals + mongolia + tasman, data = globwarm )
```
From these results, we can reject the null hypothesis and be confident that there is correlation of errors in the data.

### Finding Unusual Observations

### Leverage
leverage points are extreme in the predictor space.  
**half normal plot** identifying unusually large values of leverage. 
```{r}
#we are looking for outliers in third plot:
countries <- row.names( savings )
hatv <- hatvalues( savings_mod )
head( hatv )
sum( hatv )


halfnorm( hatv, labs = countries, ylab = 'Leverages' )
```
If we standardize the residuals we can see how many standard deviations points are from the distribution center

```{r}
qqnorm( rstandard( savings_mod ) )
abline( 0,1 )
```

### Outliers
A point that does not fit the current model well.


Simulate some data to take a look at how outliers may impact a model fit:
```{r message=FALSE, warning=FALSE}
testdata <- data.frame( x = 1:10, y = 1: 10+rnorm( 10 ) )
lmod <- lm( y ~ x, testdata )

#an outlier with a central predictor
p1 <- rbind( testdata, c( 5.5, 12 ) )
lmod1 <- lm( y ~ x, p1 )
plt1 <- ggplot( p1, aes( x = x, y = y ) ) +
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) + 
  geom_smooth( method = "lm", alpha = .15 ) +
  geom_smooth( data = testdata, method = 'lm', alpha = 0.15 ) +
  theme_classic() +
  geom_point( shape = 19, alpha = 0.5, size = 3, color = 'red', aes( x = 5.5, y = 12 ) ) +
  ggtitle( 'Outlier with little leverage' ) +
  xlim( c( 0, 15 ) ) +
  ylim( c( 0, 18 ) )
plt1


#an extra point well outside the range of the data
p2 <- rbind( testdata, c( 15, 15.1 ) )
lmod2 <- lm( y ~ x, p2 )
plt2 <- ggplot( p2, aes( x = x, y = y ) ) +
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) + 
  geom_smooth( method = "lm", alpha = .15 ) +
  geom_smooth( data = testdata, method = 'lm', alpha = 0.15 ) +
  theme_classic() +
  geom_point( shape = 19, alpha = 0.5, size = 3, color = 'red', aes( x = 15, y = 15.1 ) ) +
  ggtitle( 'Large leverage but is not an Outlier' ) +
  xlim( c( 0, 15 ) ) +
  ylim( c( 0, 18 ) )


#an outlier with leverage
p3 <- rbind( testdata, c( 15, 5.1 ) )
lmod3 <- lm( y ~ x, p3 )
plt3 <- ggplot( p3, aes( x = x, y = y ) ) +
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3 ) + 
  geom_smooth( method = "lm", alpha = .15 ) +
  geom_smooth( data = testdata, method = 'lm', alpha = 0.15 ) +
  theme_classic() +
  geom_point( shape = 19, alpha = 0.5, size = 3, color = 'red', aes( x = 15, y = 5.1 ) ) +
  ggtitle( 'Large leverage and an Outlier' ) +
  xlim( c( 0, 15 ) ) +
  ylim( c( 0, 18 ) )

grid.arrange( plt1, plt2, plt3, ncol = 2 )
```

Bonferroni Correction

```{r}
stud <- rstudent( lmod )
stud[ which.max( abs( stud ) ) ]
#compute the Bonferroni critical value:
qt( 0.05 / ( 50*2 ), 44 )
```

A dataset with multiple outliers
```{r}
data( star, package = 'faraway' )
plt1 <- ggplot( star, aes( x = temp, y = light ) ) +
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3  ) +
  geom_smooth( method = 'lm' )
  theme_classic()
  
plt1
```

assess the data for outliers:
```{r}
range( rstudent( lm( light ~ temp, star ) ) )
```

```{r}
star2 <- star %>% filter( temp >3.6 )
plt1 + geom_smooth( data = star2, method = 'lm' )
```
When the four data point that represent four stars that are gas giants. then they are removed, the linear relationship between light intensity and core temperature is described by very different coefficients.  

### Influential Observations
**Influential Data Points**: cause a shift in the relationship of a model when removed from the data set.  
the **Cook statistic** is a good way to show influential data points and can be visualized as a half-normal plot:  
```{r}
sumary( savings_mod )
```
```{r}
cook <- cooks.distance( savings_mod )
halfnorm( cook, labs = countries, ylab = "Cook's distances" )
```
Now we evaluate the fit after removing the data point with the largest cook's distance: Libya

```{r}
savings_modi <- lm( sr ~ pop15 + pop75 + dpi + ddpi, 
                    savings, 
                    subset = ( cook < max( cook ) ) )
sumary( savings_modi )
```
```{r}
plot( savings_modi )
```

### Checking the Structure of the Model:
**Partial Regression Plots**: a look at the marginal relationship between the response and predictor variable after the effect of the other predictors has been removed. The partial regression plot allows us to focus on the relationship between one predictor and the response as in a simple regression. Better for outlier/influential point detection  
**Partial Residuals Plot**: the partial regression of a variable plotted against the variable. Better for non-linearity detection

```{r}
d <- residuals( lm( sr ~ pop75 + dpi + ddpi, savings ) )
m <- residuals( lm( pop15 ~ pop75 + dpi + ddpi, savings ) )
p <- predict( savings_mod, type = 'term', term = 'pop15' )
r <- residuals( savings_mod, type = 'partial' )[,'pop15']
dat <- data.frame( 'd' = d, 'm' = m, 'p' = p, 'r' = r, 'pop15' = savings$pop15 )



preg <- ggplot( dat, aes( x = m, y = d, ) ) +
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3  ) +
  geom_smooth( method = 'lm', se = FALSE ) +
  xlab( 'pop15 residuals' ) +
  ylab( 'Savings residuals' ) +
  ggtitle( 'Partial Regression / Added Variable Plot' ) +
  theme_classic()

pres <- ggplot( dat, aes( x = pop15.1, y = r ) ) +
  geom_point( fill = NA, shape = 21, alpha = 0.5, size = 3  ) +
  geom_smooth( method = 'lm', se = FALSE ) +
  ylab( 'Partial for pop15' ) +
  xlab( 'pop15' ) +
  ggtitle( 'Partial Residual Plot' ) +
  theme_classic()


grid.arrange( preg, pres, ncol = 2 )
```

### Exercise 6.1
Using the `sat` dataset, fit a model with the total SAT score as the response and expend, salary, ratio and takers as predictors. Perform regression diagnostics on this model to answer the following questions. Display any plots that are relevant. Do not provide any plots about which you have nothing to say. Suggest possible improvements or corrections to the model where appropriate.  

```{r}
data( sat )
glimpse( sat )
```
```{r}
sat_mod <- lm( total ~ expend + salary + ratio + takers, data = sat )
sumary( sat_mod )
```



* (a) Check the constant variance assumption for the errors
```{r}
plot( fitted( sat_mod ), residuals( sat_mod ),
      xlab = 'Fitted', ylab = 'Residuals' )
abline( h = 0 )
```
Some signs of nonlinearity? nonconstant variance?...
```{r}
plot( fitted( sat_mod ), sqrt( abs( residuals( sat_mod ) ) ),
      xlab = 'Fitted', ylab = expression( sqrt( hat( epsilon ))) )
abline( h = 0 )
```
This looks more satisfactory?

* (b) Check the normality assumption

```{r}
qqnorm( residuals( sat_mod ) )
qqline( residuals( sat_mod ) )
```
That looks reasonably normal

* (c) Check for large leverage points

```{r}
halfnorm( hatvalues( sat_mod ) )
qqnorm( rstandard( sat_mod ) )
abline( 0,1 )
```

* (d) Check for outliers
```{r}

```

* (e) Check for influential points

```{r}
cook <- cooks.distance( sat_mod )
halfnorm( cook,5 )
```
44 appears to be an outlier with leverage

* (f) Check the structure of the relationship between the predictors and the response
```{r}
termplot( sat_mod, partial.resid = TRUE, terms = 3 )
```



## Transformation
Transformations of the response and/or predictors can improve the fit and correst violations of model assumptions.

When you use a log transformation on the response, the regression coefficients hace a particular interpretatio:
$$\mbox{log}\hat{y} = \hat{\beta}_0 + \hat{\beta}_1x_1 + \cdots + \hat{\beta}_px_p$$
$$\hat{y} = e^{\hat{\beta}_0}e^{\hat{\beta}_1x_1} \cdots e^{\hat{\beta}_px_p}$$

The Box-cox transformation is a popular way to determine a transformation on the response.  

Transforming the response can make the model harder to interpret, so we do not want to do it unless it is really necessary
Here is an example with the savings data:
```{r}
data( savings )
glimpse( savings )

savings_mod <- lm( sr ~ pop15 + pop75 + dpi + ddpi, savings )
boxcox( savings_mod, plotit = T )
boxcox( savings_mod, plotot = T, lambda = seq( 0.5, 1.5, by = 0.1 ) )
```

### Transforming the Predictors

Broken Stick Regression: Sometimes we have reason to believe that different linear regression models apply to different regions of the data. Broken stick uses two basis functions to describe the distribution:
$$y = \beta_0 + \beta_1\mbox{B}_1(x) + \beta_2\mbox{B}_2(x) + \epsilon$$

Polynomials. response surfaces.

### Splines
B-spline basis functions

```{r}
funky <- function( x ) sin( 2 * pi * x^3 )^3
x = seq( 0,1,by = 0.01 )
y = funky( x ) + 0.1*rnorm( 101 )
matplot( x, cbind( y, funky(x) ), type = "pl", pch = 20, lty = 1, col = 1 )
```

look at the fits for orthogonal polynomial bases of order 4 and 12:
```{r}
g4 <- lm( y ~ poly( x, 4 ) )
g12 <- lm( y ~ poly( x, 12 ) )
matplot( x, cbind( y, g4$fit, g12$fit ), type = "pll", pch = 20, lty = c( 1,2 ), col = 1 )
```
The p4 does not fit the data well enough. However, the p14 appears to overfit.

try with splines:
```{r}
knots <- c( 0, 0, 0, 0, 0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.85, 0.9, 1, 1, 1, 1 )
bx <- splineDesign( knots, x )
lmodb <- lm( y ~ bx -1 )
matplot( x, bx, type = 'l', col = 1 )
matplot( x, cbind( y, lmodb$fit ), type = 'pl', pch = 20, lty = 1, col = 1 )
```

Smoothing spline
```{r}
ssf <- smooth.spline( x,y )
matplot( x, cbind( y, ssf$y ), type = 'pl', lty = 1, pch = 20, col = 1 )
```

## Missing Data

### Types of Missing Data

* **Missing Cases** fail to observe a complete case
* **Incomplete Values** not a full series of data
* **Missing Values** missed incidences

Types of Missingness:  

* **Missing Completely at Random (MCAR)** randomly missed cases or values
* **Missing at Random (MAR)** systematically missed cases or values
* **Missing Not at Random (MNAR)** missing due to an unobserved variable

### Deletion

```{r}
data( chmiss, package = 'faraway')
glimpse( chmiss )
```

standard summaries are a handy first peek to notice missing variables
```{r}
summary( chmiss )
```

the dataset is small enough, why not peek at the missing values by record (row)
```{r}
rowSums( is.na( chmiss ) )
```

Look for patterns in the missing data:
```{r}
image( is.na( chmiss ), axes = FALSE, col = gray(1:0) )
axis( 2, at = 0:5/5, labels = colnames( chmiss ) )
axis( 1, at = 0:46/46, labels = row.names( chmiss ), las = 2 )
```
The missing values seem to be randomly peppered throughout the data.

One strategy to deal with this is to remove all the missing values. However, this reduces the number of observations from 47 to 27. This change in sample size results in larger standard errors for a regression fit as demonstrated here:

```{r}
modmiss <- lm( data = chmiss, involact ~ . )
sumary( modmiss )
```
```{r}
data( chredlin, package = 'faraway' )
modfull <- lm( involact ~ ., data = chredlin )
sumary( modfull )
```

Deleting cases is a simple strategy, but we end up throwing away information that might allow for a more precise inference.

### Single Imputation

a tempting solution is to impute using the mean
```{r}
cmeans <- colMeans( chmiss, na.rm = TRUE )
mchm <- chmiss
for( i in c( 1:4,6 ) ) mchm[ is.na( chmiss[,i]),i ] <- cmeans[i]
imod <- lm( involact ~ ., mchm )
sumary( imod )
```
Notice how the coefficients are dragged closer to 0. Imputing with the mean has the effect of flattening the data. This has the effect of reducing the magnitude of the importance of feature variables. Mean imputation is not recommended except where the fraction of filled values is small.

Using regression methods to predict values of covariates
```{r}
lmodr <- lm( logit( race/100 ) ~ fire + theft + age + income, data = chmiss )
ilogit( predict( lmodr, chmiss[ is.na( chmiss$race ),]))*100
```

compare these predicted values to the real data
```{r}
chredlin$race[ is.na( chmiss$race ) ]
```

The regression fill-in will also introduce a bias toward zero in the coefficients and reduce variance, but it's not as accute as imputation by the mean.

### Multiple Imputation
The problem with single imputation is that the imputed value, be it a mean or a regression-predicted value, tends to be less variable than the value we would have seen because the imputed value does not include the error variation that would normally be seen in observed data. Multiple imputation reincludes the error.  
Here we use the `Amelia` package to perform multiple Imputation
```{r}
set.seed( 123 )
chimp <- amelia( chmiss, m=25 )
```
now fit a linear model to the 25 imputed datasets and store the results:
```{r}
betas <- NULL
ses <- NULL
for(i in 1:chimp$m ){
  lmod <- lm( involact ~ race + fire + theft + age, chimp$imputations[[i]])
  betas <- rbind( betas, coef( lmod ) )
  ses <- rbind( ses, coef( summary( lmod ) )[,2])
}
```

use the `mi.meld()` function to find the beta estimate as well as the standard error. 
```{r}
cr <- mi.meld( q = betas, se = ses )
cr
```

### Exercises

#### 13.1


#### 13.2

## Problems with Predictors

### Errors in Predictors

The measurement error issue.  
```{r}
data( cars )
cars_mod <- lm( dist ~ speed, data = cars )

cars_p1 <- ggplot( cars, aes( x = speed, y = dist ) ) +
  geom_point() +
  geom_smooth( method = 'lm', se = F, color = 'black' ) +
  theme_classic()

cars_p1
```

the effect of adding measurement error to the predictor
```{r}
cars_mod1 <- lm( dist ~ I( speed + rnorm( dim( cars )[1] )), data = cars )
cars_mod2 <- lm( dist ~ I( speed + 2*rnorm( dim( cars )[1] )), data = cars )
cars_mod5 <- lm( dist ~ I( speed + 5*rnorm( dim( cars )[1] )), data = cars )
cars_p1 + 
  geom_abline(slope = cars_mod1$coefficients[2], intercept = cars_mod1$coefficients[1], color = 'yellow' ) +
  geom_abline(slope = cars_mod2$coefficients[2], intercept = cars_mod2$coefficients[1], color = 'orange' ) +
  geom_abline(slope = cars_mod5$coefficients[2], intercept = cars_mod5$coefficients[1], color = 'red' )
```

The slope gets shallower as the error increases.

Here we simulate the effects of adding normal random error:
```{r}
vv <- rep( 1:5/10, each=1000 )
slopes <- numeric( 5000 )
for ( i in 1:5000 ) slopes[i] <- lm( dist ~ I( speed + sqrt( vv[i] )*rnorm( dim( cars )[1] )), data = cars )$coef[2]
#plot the mean slopes for each variance
betas <- c( coef( cars_mod )[2], colMeans( matrix( slopes, nrow=1000 ) ) )
variances <- c( 0, 1:5/10 ) + 0.5
plot( variances, betas, xlim = c( 0,1 ), ylim = c( 3.86,4 ) )
#fit a linear model and extrapolate to 0 variance
gv <- lm( betas ~ variances )
coef( gv )
points( 0, gv$coef[1], pch=3 )
```

The predicted value of $\hat{\beta}$ at variance equal to zero, that is no measurement error, is 4.0.  

Here is a prediction result using the `simex` package:
```{r}
set.seed( 123 )
lmod <- lm( dist ~ speed, cars, x = T )
simout <- simex( lmod, "speed", 0.5, B=1000 )
simout
```

### Changes in Scale 
most methods work more reliably  when variables are on roughly similar scales.

```{r}
sumary( savings_mod )
```

rescale to measure income in thousands instead of dollars
```{r}
savings_mod_scale <- lm( sr ~ pop15 + pop75 + I(dpi/1000) + ddpi, data = savings )
sumary( savings_mod_scale )
```

another approach is the use the function `scale()`
the regression coefficients now represent the effect of a one standard unit increase in the predictor on the response in standard units
```{r}
savings_scaled <- data.frame( scale( savings ) )
savings_mod_scale2 <- lm( sr ~ ., savings_scaled )
sumary( savings_mod_scale2 )
```

Now, with the predictors on a common scale, it is helpful to construct plot estimates with confidence intervals
```{r}
edf <- data.frame( coef( savings_mod_scale2 ), confint( savings_mod_scale2 ) )[-1,]
names( edf ) <- c( 'Estimate', 'lb', 'ub' )

p <- ggplot( aes( y = Estimate, ymin = lb, ymax = ub, x = row.names( edf ) ), data = edf ) +
  geom_pointrange() +
  coord_flip() +
  xlab( 'Predictor' ) +
  geom_hline( yintercept = 0, col = gray( 0.75 ) ) +
  ggtitle( 'standardized coefficients', subtitle = 'confidence intervals shown' )
p
```

Scaling with binary predictors:
```{r}
#take a look at the variable pop15 for age
ggplot( aes( x = pop15 ), data = savings ) +
  geom_histogram()
```

The data is bimodal. we can create a binary variable for age that divides at `pop15`=35
```{r}
savings$age <- ifelse( savings$pop15 > 35, 0, 1 )
```

A binary predictor taking the values of 0/1 with equal probability has a standard deviation of one half. This suggests scaling the other continuous predictors by two SDs rather than one:
```{r}
savings$dpis <- (savings$dpi - mean( savings$dpi ))/(2*sd( savings$dpi ) )
savings$ddpis <- (savings$ddpi - mean( savings$ddpi ))/(2*sd( savings$ddpi ) )
sumary( lm( sr ~ age + dpis + ddpis, savings ) )
```

### Colinearity
**colinearity**: when some predictors are linear combinations of others. $X^TX$ is singular  
**multicolinearity**: $X^TX$ is close to singular but not exactly  

detecting collinearity:  

* correlation matrix values are close to $\pm$1, indicating large pairwise collinearities
* a regression of $x_i$ on all other predictors gives $R^2_i$. $R^2_i \sim 1$ is bad and means one predictor can be be predicted by a linear combination of other predictors.
* Examine the eigenvalues. eigenvalues close to 0 denote collinearity.

```{r}
data( seatpos, package = 'faraway' )
seatpos_mod <- lm( hipcenter ~ ., data = seatpos )
sumary( seatpos_mod )
```
none of the predictors are significant, yet, the $R^2$ is fairly large.  
now to look at the pairwise correlations
```{r}
seatpos_cor <- round( cor( seatpos[,-9] ), 2 )
seatpos_cor
```
ok, that's not very intuitive. 
```{r}
ggcorrplot( seatpos_cor )
```
There are several large pairwise correlations.  
now to check the eigenvalue decomposition
```{r}
x <- model.matrix( seatpos_mod )[,-1]
e <- eigen( t(x) %*% x )
e$val
```
```{r}
sqrt( e$val[1]/e$val )
```
compute the variance inflation factors:
```{r}
vif( x )
```

let's look at the correlation for all the length measurements:
```{r}
seatpos_length_cor <-round( cor( x[,3:8] ), 2 )
seatpos_length_cor
ggcorrplot( seatpos_length_cor )
```

let's take a look at model performance when we use just one length predictor, height
```{r}
seatpos_mod2 <- lm( hipcenter ~ Age + Weight + Ht, data = seatpos )
sumary( seatpos_mod2 )
```

We get the same explanatory power but with a simpler model

## Model Selection  
The problem of selecting the best subset of predictors.  
**Occam's Razor**: among several plausible explanations for a phenomenon, the simplest is the best.  

### Hierarchical Models
Do not remove the lower order terms in the presence of higher order terms.  

### Testing baes procedures  

* Backwards Elimination - start with the kitchen sink. one-by-one remove the predictors with the highest p-values that are $\gt \alpha$
* Forwards Elimination - start with nothing. try a model fit with each variable and progress with the variables that results in the smallest p-value. repeat this process until there are no more choices that lead to a better p-value.  
* Stepwise Regression - a combination of forwards and backwards elimination.  

```{r}
data( state )
statedata = data.frame( state.x77, row.names = state.abb )
state_mod <- lm( Life.Exp ~ ., statedata )
sumary( state_mod )
```

remove the predictor with the highest p-val:
```{r}
state_mod <- update( state_mod, . ~ . - Area )
sumary( state_mod )
```
remove the predictor with the highest p-val:
```{r}
state_mod <- update( state_mod, . ~ . - Illiteracy )
sumary( state_mod )
```

remove the predictor with the highest p-val:
```{r}
state_mod <- update( state_mod, . ~ . - Income )
sumary( state_mod )
```

remove the predictor with the highest p-val:
```{r}
state_mod <- update( state_mod, . ~ . - Population )
sumary( state_mod )
```

However, it is important to understand that the variables omitted from the model may still be related to the response.  

Drawbacks to step-based procedures  

* it is possible to miss the optimal model
* the p-vals should not be treated too literally
* variables that get dropped may still be correlated to the response of interest
* step-wise variable selection methods tend to pick models that are smaller than desirable for prediction purposes

### Criterion-Based Procedures 
Choosing a model that optimizes a criterion.  
**Kullback-Leiber information** (distance): $I(f,g)=\int f(x)log(\frac{f(x)}{g(x|\theta)})$  
but we don't know $f$. sad face.  ...
**Akaike Information Criterion**: $AIC = -2L(\hat{\theta}) +2p$  
Choose the model that minimizes the AIC. AIC naturally balances between fit and simplicity in model selection  
**Bayed Information Criterion** (BIC)

```{r}
b <- regsubsets( Life.Exp ~ ., data = statedata )
rs <- summary( b )
rs$which
```
```{r}
AIC <- 50*log(rs$rss/50)+(2:8)*2
plot( AIC ~ I(1:7), ylab = 'AIC', xlab="Number of Predictors")
```
AIC is minimized by a choice of 4 predictors

Using $R^2_{adj}$
```{r}
plot( 2:8, rs$adjr2, xlab = 'No. of parameters', ylab = 'Adjusted R-squared')
which.max( rs$adjr2 )
```

Mallow's Cp statistic
```{r}
plot( 2:8, rs$cp, xlab = 'No. of parameters', ylab = 'Cp statistic')
abline( 0,1 )
```

`step()`
```{r}
state_mod <- lm( Life.Exp ~ ., data = statedata )
step( state_mod )
```

The sequence of variable removal is the same as with backward elimination and the model selected is the same as for AIC.  

Check for high leverage:
```{r}
h <- lm.influence( state_mod )$hat
names(h) <- state.abb
rev( sort( h ) )
```
Alaska has high leverage. retry fitting without Alaska:
```{r}
b <- regsubsets( Life.Exp ~ ., data = statedata, subset = ( state.abb!="AK"))
rs <- summary( b )
rs$which[ which.max( rs$adjr2 ),]
```
`AREA` is now included in the model  

Now observe the data and see if transformations are necessary
```{r}
stripchart( data.frame( scale( statedata ) ), method = 'jitter', las = 2, vertical = TRUE )
```

both `AREA` and `Population` are skewed. re-evaluate the model:
```{r}
b <- regsubsets( Life.Exp ~ log( Population ) + Income + Illiteracy + Murder + HS.Grad + Frost + log( Area ), data = statedata )
rs <- summary( b )
rs$which[which.max( rs$adjr2),]
```

While selecting models, think about:  

* Do the models have similar qualitative consequences?
* Do they make similar predictions?
* What is the cost of measuring the predictors?
* Which has the best diagnostics?


## Shrinkage Methods  
More predictors in a model mean more information. This chapter looks at how to shrink the additional information into a more useful (interpretable) form.  

### Principal Components
**Principal Component Analysis** (PCA): finding low-dimensional linear structure in higher dimensional data.  
find the orthogonal directions of the greatest variation in the data
```{r}
cfat <- fat[,9:18]
prfat <- prcomp( cfat, scale = TRUE )
dim( prfat$rot )
dim( prfat$x )
summary( prfat )
round( prfat$rot[,1],2 )
```

**Mahalanobis Distance**: is a measure of the distance of a point from the mean that adjusts for the correlation in the data.
```{r}
robfat <- cov.rob( cfat )
md <- mahalanobis( cfat, center = robfat$center, cov=robfat$cov )
n <- nrow( cfat ); p <- ncol( cfat )
plot( qchisq( 1:n/(n+1), p), sort(md), 
      xlab = expression( paste( chi^2,"quantiles")), 
      ylab = "Sorted Mahalanobis Distances")
abline( 0,1 )
```
use the 1st 2 PCs to model the data
```{r}
lmodpcr <- lm( fat$brozek ~ prfat$x[,1:2] )
sumary( lmodpcr )
```

Take a few representative predictors based on the two largest coefficients seen in the PCs:
from the first 2 PCs, go with `Abdomen` and `Ankle`-`Abdomen`
abdomen wasn't the largest coef in PC1, but going with it keeps the model down to 2 features whereas going with the largest (`Hip`) adds a 3rd predictor.
```{r}
lmodr <- lm( fat$brozek ~ scale( abdom ) + I( scale( ankle ) - scale( abdom ) ), data = cfat )
sumary( lmodr )
```

There we go: we have a simple model that fits as well as the 10 predictor model. We can interpret it similarly to the previous model but it is easier to explain to others. Future studies might be done more cheaply because we might only need these two measures.  


Build a model to predict the fat content of new samples using the 100 absorbances which can be measured more easily:
```{r}
data( meatspec, package = 'faraway' )
#glimpse( meatspec )
trainmeat <- meatspec[ 1:172, ]
testmeat <- meatspec[ 173: 215,]
meat_mod <- lm( fat ~ ., trainmeat )
# r^2 for the kitchen sink
summary( meat_mod )$r.squared
```
compare the rmse for the train and test sets
```{r}
rmse <- function( x,y ) sqrt( mean( (x-y )^2 ) )
rmse( fitted( meat_mod ), trainmeat$fat )
rmse( predict( meat_mod, testmeat ), testmeat$fat )
```
Performance is much worse for the test data.

OKay, so there are 100 features in this dataset. We probably don't need them all.
Next try a stepwise feature selection method:
```{r message = F, echo=F, results='hide'}
meat_mod_step <- step( meat_mod, trace = F );
rmse( meat_mod_step$fit, trainmeat$fat )
rmse( predict( meat_mod_step, testmeat ), testmeat$fat )
```
~28 features were dropped and performance was increased a bit.

Now let's go with PCR
```{r}
meatpca <- prcomp( trainmeat[, -101 ] )
round( meatpca$sdev, 3 )
```
```{r}
matplot( 1:100, meatpca$rot[,1:3], type = 'l', xlab = 'Frequency', ylab = '', col = 1 )
```
PCR
```{r}
meatpcr <- pcr( fat ~ ., data = trainmeat, ncomp = 50 )
rmse( predict( meatpcr, ncomp = 4 ), trainmeat$fat )
```

```{r}
par(mfrow=c(1,2))
#plot the 100 slope coefs for the kitchen sink
plot( meat_mod$coef[-1], xlab = 'Frequency', ylab = 'Coefficient', type = 'l' )
coefplot( meatpcr, ncomp = 4, xlab = 'Frequency', main = '' )
```
we used 4 PCs, why? How to select the number: *skree* plot (plot of stds)
```{r}
plot( meatpca$sdev[ 1:10 ], type = 'l', ylab = 'SD of PC', xlab = 'PC number' )
```
General rule of thumb: use PCs up to the last 'elbow' in the skree plot

How well does 4 PCs work with the test data?
```{r}
rmse( predict( meatpcr, testmeat, ncomp = 4 ), testmeat$fat )
```

```{r}
pcrmse <- RMSEP( meatpcr, newdata = testmeat )
plot( pcrmse, main = '' )
which.min( pcrmse$val )
```
```{r}
pcrmse$val[ 28 ]
```
The best result occurs fro 28 PCs.  

**Crossvalidation**  
```{r}
set.seed( 123 )
meatpcr <- pcr( fat ~ ., data = trainmeat, validation = 'CV', ncomp = 50 )
meatCV <- RMSEP( meatpcr, estimate = 'CV' )
plot( meatCV, main = '' )
minPCs <- which.min( meatCV$val )
ypred <- predict( meatpcr, testmeat, ncomp = minPCs )
rmse( ypred, testmeat$fat )
```

This gives a much more improved RMSE

### Partial Least Squares  
a method for relating a set of input variables and outputs  
apply PLS using CV to select components:
```{r}
par(mfrow=c(1,2))
set.seed( 123 )
meatpls <- plsr( fat ~ ., data = meatspec[1:172,], ncomp=50, validation = "CV" )
coefplot( meatpls, ncomp = 4, xlab = "Frequency", main = "" )
plsCV <- RMSEP( meatpls, estimate = 'CV' )
plot( plsCV, main="" )
```
From the right hand figure, we see we need around 15 components  
see how it performs on the train set:
```{r}
ypred <- predict( meatpls, ncomp = 15 )
rmse( ypred, trainmeat$fat )
```
see how it performs on the test set:
```{r}
ytpred <- predict( meatpls, testmeat, ncomp = 15 )
rmse( ytpred, testmeat$fat )
```
We did slightly better than PCR.

### Ridge Regression
Suppose that the predictors have been centered by their means and scaled by their standard deviations and that the response has been centered.

### Lasso Regression
Lasso regression is pretty good when there are lots of predictors. Lasso is particularly good when we believe the effects are sparse; that few of the predictors have an effect.
```{r}
trainy <- trainmeat$fat
trainx <- as.matrix( trainmeat[,-101] )
meatlasso <- lars( trainx, trainy )
```

now the CV
```{r}
set.seed( 123 )
cvout <- cv.lars( trainx, trainy )
cvout$index[ which.min( cvout$cv ) ]
testx <- as.matrix( testmeat[,-101] )
predlars <- predict( meatlasso, testx, s=0.0101, mode='fraction')
rmse( testmeat$fat, predlars$fit )
```

Thats the best RMSE so far.  
```{r}
predlars <- predict( meatlasso, s = 0.0101, type = "coef", mode="fraction" )
plot( predlars$coef, type = 'h', ylab="Coefficient" )
sum( predlars$coef != 0 )
```













<br><br><br>