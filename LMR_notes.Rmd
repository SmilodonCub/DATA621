---
title: 'Linear Models with `R`'
subtitle: 'by Julian Faraway'
author: 'notes by Bonnie Cooper'
output:
  rmdformats::downcute
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The following are notes from readings in ['A Modern Approach to Regression with `R`'](https://www.routledge.com/Linear-Models-with-R/Faraway/p/book/9781439887332) by Julian Faraway for the course DATA621, 'Business Analystics and Data Mining' as part of the [Masters of Science in Data Science program at CUNY SPS](https://sps.cuny.edu/academics/graduate/master-science-data-science-ms).

`R` libraries used:
```{r message=FALSE}
library( faraway )
library( dplyr )
library( ggplot2 )
library( gridExtra )
library( tidyverse )
library( HistData )
library( broom )
library( gclus )
```

## Introduction
*"The formulation of a problem is often more essential than its solution"*

**Formulate the Problem Correctly**  

* Understand the Physical Background
* Understand the Objective
* Make sure you know what the client wants
* Put the Problem into Statistical Terms
  + observational or experimental data?
  + Is there Nonresponse?
  + Are there Missing Values?
  + How are the Data Coded?
  + What are the Units of Measurement?
  + Beware of data entry errors and other forms of data corruption
  
  
### Initial Data Analysis  
Critical to do an initial exploration to get the feel for the data. summary statistics. basic visualizations. inspect quality of the data...

look at some practice data:
```{r}
data( pima )
head( pima )
```
```{r}
summary( pima )
```

Not all missing values are `NA`. the minimum for `diastolic` is $0$. However, that's not a realistic value for a living person. Therefore, it is more likely that this is a missing value. Look closer at `diastolic`:
```{r}
sort( pima$diastolic )[1:100]
```
clean these values up for `diastolic` and the other similar numeric variables
```{r}
pima_NA <- pima %>%
  mutate( diastolic =  na_if( diastolic, 0 ),
             glucose = na_if( glucose, 0 ),
             triceps = na_if( triceps, 0 ),
             insulin = na_if( insulin, 0 ),
             bmi = na_if( bmi, 0 ) ) 
glimpse( pima_NA )
```
change the `test` feature to a categorical with descriptive labels:
```{r}
pima_NA$test <- factor( pima_NA$test )
levels( pima_NA$test ) <- c( 'negative', 'positive' )
summary( pima_NA$test )
```
Do some basic visualization of some features:
```{r}
par(mfrow=c(1,3))
pimahist <- hist( pima_NA$diastolic, xlab='Diastolic',main='' )
pimadens <- plot( density( pima_NA$diastolic, na.rm=TRUE ), main="" )
pimasort <- plot( sort( pima_NA$diastolic ), ylab = 'Sorted Diastolic' )
```

Now try again with ggplot:
```{r}
pimahist <- ggplot( pima_NA, aes( x = diastolic ) ) +
  geom_histogram()
pimadens <- ggplot( pima_NA, aes( x = diastolic ) ) +
  geom_density()
sdiastolic <- sort( pima_NA$diastolic )
pima_sort <- data.frame( 'sorted' = sdiastolic )
pimasort <- ggplot( pima_sort, aes( y = sorted, x = 1:length( sdiastolic ) ) ) +
  geom_point()

grid.arrange( pimahist, pimadens, pimasort, ncol = 3 )
```

Visualize some bivariate data
```{r}
p1 <- ggplot( pima_NA, aes( x = diastolic, y = diabetes ) ) +
  geom_point()

p2 <- ggplot( pima_NA, aes( x = test, y = diabetes ) ) +
  geom_boxplot()

grid.arrange( p1, p2, ncol = 2 )
```

`ggplot2` is a handy library that is more flexible when visualizing complex dataframes. For instance: controlling color/shape/fill by another variables, or creating faceted plots:
```{r}
#bisambiguating a factor variable:
p1 <- ggplot( pima, aes( x = diastolic, y = diabetes, color = factor( test ) ) ) +
  geom_point() +
  theme( legend.position = 'top',
         legend.direction = 'horizontal' )
p2 <- ggplot( pima, aes( x = diastolic, y = diabetes ) ) +
  geom_point( size = 1 ) +
  facet_grid( ~ factor( test ) )

grid.arrange(p1, p2, ncol=2,top="Disambiguating a factor variable")
```
**On Visualizations**: Good graphics are vital in data analysis. They help you avoid mistakes and suggest the form of the modeling to come. They are also important in communicating your analysis to others. Many in your audience or readership will focus on the graphs. This is your best opportunity to get your message over clearly and without misunderstanding. In some cases, the graphics can be so convincing that the formal analysis becomes just a confirmation of what has already been seen

### When to use Linear Modeling
**Linear Modeling** is used for explaining or modeling the relationship between a response/outcome/output variable and one or more predictor/input/explanatory variable(s).  
**Simple Regression**: modeling an outcome variable with just 1 explanatory variable.  
**Mulitple/Multivariate Regression**: modeling an outcome variable with more than 1 explanatory varaible.  

**Regression Objectives**  

* Prediction of future or unseen responses given specified values of the predictors
* Assessment of an effect, or relationship between, explanatory variables and the response

### History of Regression
describing the [libration of the moon](https://www.google.com/books/edition/The_History_of_Statistics/M7yvkERHIIMC?hl=en&gbpv=1&dq=stigler+1986&pg=PA1&printsec=frontcover):
```{r}
data( manilius )
glimpse( manilius )
```
The data are divided into three groups based on similarity. Next, compute the sum of the three coefficients by group.

```{r}
moon3 <- manilius %>%
  group_by( group ) %>%
  summarise( arc_sum = sum( arc ),
             sin_sum = sum( sinang ),
             cos_sum = sum( cosang ) )
moon3
```
The result are 3 linear equations with three unknowns each to solve
```{r}
solve( cbind( 9, moon3$sin_sum, moon3$cos_sum ), moon3$arc_sum )
```
Observe how similar the results are if we fit a linear regression to the original data:
```{r}
mod <- lm( arc ~ sinang + cosang, manilius )
summary( mod )
```
The word regression derives from a term of Sir Francis Galton's: *regression to mediocrity*  
**Important**: regression to mediocrity refers to a particular statistical finding and is quite a different concept to that of regression.  
Sir Francis Galton found that outcomes have a tendency towards the mean of the data using the heights of parents and their offspring. That is, tall parents are more likely to have a child shorter than they are and short parents are more likely to have a child taller than they are.  
Here we explore this data:  
```{r}
data( GaltonFamilies )
ggplot( GaltonFamilies, aes( x = midparentHeight,
                             y = childHeight ) ) +
  geom_point( size = 3 )
```
find the linear regression line the best fits the distribution
```{r}
mod <- lm( childHeight ~ midparentHeight, GaltonFamilies )
coef( mod )
```
```{r}
ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" )
```
Let's add the line that describes a relation where parents have children the same height as they are...
```{r}
ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" ) +
  geom_line( aes( y = midparentHeight ), color = 'red' )
```

Now suppose children height is fully correlated to thier parents. We can use the following equation:
$$\frac{y-\bar{y}}{SD_y} = r\frac{x-\bar{x}}{SD_x}$$
where the correlation, $r = 1$ to find the coefficients of a line describing this:
```{r}
beta <- with( GaltonFamilies,
                sd( childHeight )/ sd( midparentHeight ) )
alpha <- with( GaltonFamilies,
               mean( childHeight ) - 
                 beta * mean( midparentHeight ) )

ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" ) +
  geom_line( aes( y = midparentHeight ), color = 'red' ) +
  geom_abline(data=GaltonFamilies, aes(slope=beta, intercept=alpha ), color='green' )
```

**Regression to the Mean**: We can see that a child of tall parents is predicted by the least squares line to have a height which is above average but not quite as tall as the parents as
the green line would have you believe. Similarly children of below average height parents are predicted to have a height which is still below average but not quite as short as the parents. This is why Galton used the phrase “regression to mediocrity” and the phenomenon is sometimes called the regression effect.

### Recommended Exercises:
**1.1** The dataset `teengamb` concerns a study of teenage gambling in Britain. Make a numerical and graphical summary of the data, commenting on any features that you find interesting. Limit the output you present to a quantity that a busy reader would find sufficient to get a basic understanding of the data.

The `teengamb` dataset:
```{r}
data( teengamb )
glimpse( teengamb )
```
```{r}
teengamb_clean <- teengamb %>%
  mutate( sex = factor( sex ),
          status = factor( status ) )
summary( teengamb_clean )
```
The numerical summary shows the distribution of subjects in each group for the categorical variables `sex` and `status` as well as the mode/spread of the numerical features: `income` (lbs/wk), `verbal`, and `gamble` (annual).

and now to visualize the data:
```{r}
#visulize the numeric features by group features
si <- ggplot( teengamb_clean, aes( x = sex, y = income, fill = sex ) ) +
  geom_boxplot()
sv <- ggplot( teengamb_clean, aes( x = sex, y = verbal, fill = sex ) ) +
  geom_boxplot()
sg <- ggplot( teengamb_clean, aes( x = sex, y = gamble, fill = sex ) ) +
  geom_boxplot()

grid.arrange( si, sv, sg, ncol = 3 )

sti <- ggplot( teengamb_clean, aes( x = status, y = income, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")
stv <- ggplot( teengamb_clean, aes( x = status, y = verbal, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")
stg <- ggplot( teengamb_clean, aes( x = status, y = gamble, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")

grid.arrange( sti, stv, stg, ncol = 3 )
```
For `sex`, both genders have a very similar distribution of `income` and `verbal` scores. However, one gender has a very different distribution for the annual gambling expenditure.

There appears to be a linear relationship between `verbal` scores and `status` although for other features, the relationship is less clear. However, without knowing the meaning behind the `status` designations, it is difficult to tell.

Look at how some variable covary:
```{r}
ggplot( teengamb_clean, aes( y = gamble, x = income, color = sex ) ) + geom_point( size = 3 ) +
  geom_smooth(method = "lm", alpha = .15, aes(fill = sex))
```
If we plot the amount gambled against weekly income we see two very different trends for the different genders. Males (0) increase their gambling as a function of their weekly income whereas females (1), do not tend to gamble nor show the trend of increasing gambling with increasing income.

Let's take a look at the coefficients for these regression lines:
```{r}
teengamb_clean %>% group_by( sex ) %>%
  do( gambling = broom::tidy( lm( gamble ~ income, data = .))) %>% 
  unnest( gambling )
```
for every GBP increase in weekly income, a male British teen gambles 6.5GBP more annually. However, there is only a negligible increase for females of 0.17.


**1.3** The dataset `prostate` is from a study on 97 men with prostate cancer who were due to receive a radical prostatectomy. Make a numerical and graphical summary of the data as in the first question.

```{r}
data( prostate )
glimpse( prostate )
```
let's learn what the variables are before proceeding:  

* lcavol -> log(cancer volume)
* lweight -> log(prostate weight)
* age -> age (years)
* lbph -> log(benign prostatic hyperplasia amount)
* svi -> seminal vesicle invasion
* lcp -> log(capsular penetration)
* gleason -> Gleason score
* pgg45 -> percentage Gleason scores 4 or 5
* lpsa -> log(prostate specific antigen)

observe summaries of each feature:
```{r}
# svi appears to be binary, so make that adjust:
prostate_clean <- prostate %>%
  mutate( svi = factor( svi ) )
summary( prostate_clean )
```
generate a matrix plot ordered by degree of correlation:
```{r}
dta <- prostate_clean %>%
  select( -c( svi, gleason ) )
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```
we observe a number of cross-correlations that might need attention for further analysis. For example, `lbph`, or the amount of benign prostatic hyperplasia amount is highly correlated with the weight of the prostate, `lweight`.

the Gleason Score assesses the severity of prostate cancer: A Gleason score of 6 is low grade, 7 is intermediate grade, and a score of 8 to 10 is high grade cancer.

We might be interested in using these features to find out what is predictive of `gleason`. How predictive are certain data features correlate with the Gleason Score?

**1.4** The dataset `sat` comes from a study entitled “Getting What You Pay For: The Debate Over Equity in Public School Expenditures.” Make a numerical and graphical summary of the data as in the first question.

```{r}
data( sat )
glimpse( sat )
```
observe the general properties of each variable
```{r}
summary( sat )
```
generate a matrix plot ordered by degree of correlation:
```{r}
dta <- sat
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```

Plot the trends for sat scores as a function of expenditure:
```{r}
sat_scores <- sat %>%
  select( expend, verbal, math ) %>%
  pivot_longer( cols = c( verbal, math ), 
                names_to = 'testcat',
                values_to = 'score' )
ggplot( sat_scores, aes( x = expend, y = score, color = testcat ) ) +
  geom_point( size = 2 ) +
  ylab( 'score' )
```
This plot suggests that there is a negative relationship between the expenditures of a state and the average sat scores for both math and verbal.

```{r}
sat_scores %>% group_by( testcat ) %>%
  do( exscor = broom::tidy( lm( score ~ expend, data = .))) %>% 
  unnest( exscor )
```

look at the cummulative scores
```{r}
sat_total_lm <- sat %>%
  do( totalsat = broom::tidy( lm( total ~ expend, data = . ) ) ) %>%
  unnest( totalsat )
sat_total_lm
```
Although the negative relationship is significant, this does not take into account an important confounding variable: the percentage of students that takes the exam:

```{r}
ggplot( sat, aes( y = total, x = takers ) ) +
  geom_point( size = 2 )
```
Perform a multiple linear regression that includes the percentage of people taking the sat
```{r}
satmod <- lm( total ~ expend + takers, sat )
summary( satmod )
```
There is a dramatic improvement in the model fit when percentage of sat test takers is included. However, there is definitely room for improving on this model. For instance, the 'U' shaped envelope of the relationship between total score and percent test takers hints at a nonlinearity. Additionally, there are more data features in the set that could be explored.

**1.5** The dataset 'divusa' contains data on divorces in the United States from 1920 to 1996. Make a numerical and graphical summary of the data as in the first question.

```{r}
data( divusa )
glimpse( divusa )
```
inspect the summary stats:
```{r}
summary( divusa )
```
Use `facet_wrap()` to look at how each of the features varies with time (`year`):
```{r}
divusa_long <- divusa %>%
  pivot_longer( cols = c( divorce, unemployed, femlab, marriage, birth, military ), names_to = 'cat', values_to = 'val' )
ggplot( aes( x = year, y = val ), data = divusa_long ) +
  geom_line() +
  #geom_point() +
  facet_wrap( ~ cat )
```
There are a few trends we see that occur over time:  

* the increase in percentage of women in the workplace
* spikes in military/femlab/divorce/marriage coinciding with WW2
* a peak in unemployment corresponding with the great depression

and now to view pairwise comparisons:
```{r}
dta <- divusa
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```
There are several relationships that look interesting to explore further:  

* the percentage of women in the workplace has a positive correlation with the divorce rate and a negative relationship with the marriage rate.
* the birth rate has a similar relationship: positively correlated with marriage and negatively correlated to divorce
* Not immediately clear from the previous figure: we see that divorce has a positive correlation with time whereas marriage is negative


<br><br><br>