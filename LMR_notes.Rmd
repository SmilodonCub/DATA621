---
title: 'Linear Models with `R`'
subtitle: 'by Julian Faraway'
author: 'notes by Bonnie Cooper'
output:
  rmdformats::downcute
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The following are notes from readings in ['A Modern Approach to Regression with `R`'](https://www.routledge.com/Linear-Models-with-R/Faraway/p/book/9781439887332) by Julian Faraway for the course DATA621, 'Business Analystics and Data Mining' as part of the [Masters of Science in Data Science program at CUNY SPS](https://sps.cuny.edu/academics/graduate/master-science-data-science-ms).

`R` libraries used:
```{r message=FALSE}
library( faraway )
library( dplyr )
library( ggplot2 )
library( gridExtra )
library( tidyverse )
library( HistData )
library( broom )
library( gclus )
library( asbio )
library( retistruct )
```

## Introduction
*"The formulation of a problem is often more essential than its solution"*

**Formulate the Problem Correctly**  

* Understand the Physical Background
* Understand the Objective
* Make sure you know what the client wants
* Put the Problem into Statistical Terms
  + observational or experimental data?
  + Is there Nonresponse?
  + Are there Missing Values?
  + How are the Data Coded?
  + What are the Units of Measurement?
  + Beware of data entry errors and other forms of data corruption
  
  
### Initial Data Analysis  
Critical to do an initial exploration to get the feel for the data. summary statistics. basic visualizations. inspect quality of the data...

look at some practice data:
```{r}
data( pima )
head( pima )
```
```{r}
summary( pima )
```

Not all missing values are `NA`. the minimum for `diastolic` is $0$. However, that's not a realistic value for a living person. Therefore, it is more likely that this is a missing value. Look closer at `diastolic`:
```{r}
sort( pima$diastolic )[1:100]
```
clean these values up for `diastolic` and the other similar numeric variables
```{r}
pima_NA <- pima %>%
  mutate( diastolic =  na_if( diastolic, 0 ),
             glucose = na_if( glucose, 0 ),
             triceps = na_if( triceps, 0 ),
             insulin = na_if( insulin, 0 ),
             bmi = na_if( bmi, 0 ) ) 
glimpse( pima_NA )
```
change the `test` feature to a categorical with descriptive labels:
```{r}
pima_NA$test <- factor( pima_NA$test )
levels( pima_NA$test ) <- c( 'negative', 'positive' )
summary( pima_NA$test )
```
Do some basic visualization of some features:
```{r}
par(mfrow=c(1,3))
pimahist <- hist( pima_NA$diastolic, xlab='Diastolic',main='' )
pimadens <- plot( density( pima_NA$diastolic, na.rm=TRUE ), main="" )
pimasort <- plot( sort( pima_NA$diastolic ), ylab = 'Sorted Diastolic' )
```

Now try again with ggplot:
```{r}
pimahist <- ggplot( pima_NA, aes( x = diastolic ) ) +
  geom_histogram()
pimadens <- ggplot( pima_NA, aes( x = diastolic ) ) +
  geom_density()
sdiastolic <- sort( pima_NA$diastolic )
pima_sort <- data.frame( 'sorted' = sdiastolic )
pimasort <- ggplot( pima_sort, aes( y = sorted, x = 1:length( sdiastolic ) ) ) +
  geom_point()

grid.arrange( pimahist, pimadens, pimasort, ncol = 3 )
```

Visualize some bivariate data
```{r}
p1 <- ggplot( pima_NA, aes( x = diastolic, y = diabetes ) ) +
  geom_point()

p2 <- ggplot( pima_NA, aes( x = test, y = diabetes ) ) +
  geom_boxplot()

grid.arrange( p1, p2, ncol = 2 )
```

`ggplot2` is a handy library that is more flexible when visualizing complex dataframes. For instance: controlling color/shape/fill by another variables, or creating faceted plots:
```{r}
#bisambiguating a factor variable:
p1 <- ggplot( pima, aes( x = diastolic, y = diabetes, color = factor( test ) ) ) +
  geom_point() +
  theme( legend.position = 'top',
         legend.direction = 'horizontal' )
p2 <- ggplot( pima, aes( x = diastolic, y = diabetes ) ) +
  geom_point( size = 1 ) +
  facet_grid( ~ factor( test ) )

grid.arrange(p1, p2, ncol=2,top="Disambiguating a factor variable")
```
**On Visualizations**: Good graphics are vital in data analysis. They help you avoid mistakes and suggest the form of the modeling to come. They are also important in communicating your analysis to others. Many in your audience or readership will focus on the graphs. This is your best opportunity to get your message over clearly and without misunderstanding. In some cases, the graphics can be so convincing that the formal analysis becomes just a confirmation of what has already been seen

### When to use Linear Modeling
**Linear Modeling** is used for explaining or modeling the relationship between a response/outcome/output variable and one or more predictor/input/explanatory variable(s).  
**Simple Regression**: modeling an outcome variable with just 1 explanatory variable.  
**Mulitple/Multivariate Regression**: modeling an outcome variable with more than 1 explanatory varaible.  

**Regression Objectives**  

* Prediction of future or unseen responses given specified values of the predictors
* Assessment of an effect, or relationship between, explanatory variables and the response

### History of Regression
describing the [libration of the moon](https://www.google.com/books/edition/The_History_of_Statistics/M7yvkERHIIMC?hl=en&gbpv=1&dq=stigler+1986&pg=PA1&printsec=frontcover):
```{r}
data( manilius )
glimpse( manilius )
```
The data are divided into three groups based on similarity. Next, compute the sum of the three coefficients by group.

```{r}
moon3 <- manilius %>%
  group_by( group ) %>%
  summarise( arc_sum = sum( arc ),
             sin_sum = sum( sinang ),
             cos_sum = sum( cosang ) )
moon3
```
The result are 3 linear equations with three unknowns each to solve
```{r}
solve( cbind( 9, moon3$sin_sum, moon3$cos_sum ), moon3$arc_sum )
```
Observe how similar the results are if we fit a linear regression to the original data:
```{r}
mod <- lm( arc ~ sinang + cosang, manilius )
summary( mod )
```
The word regression derives from a term of Sir Francis Galton's: *regression to mediocrity*  
**Important**: regression to mediocrity refers to a particular statistical finding and is quite a different concept to that of regression.  
Sir Francis Galton found that outcomes have a tendency towards the mean of the data using the heights of parents and their offspring. That is, tall parents are more likely to have a child shorter than they are and short parents are more likely to have a child taller than they are.  
Here we explore this data:  
```{r}
data( GaltonFamilies )
ggplot( GaltonFamilies, aes( x = midparentHeight,
                             y = childHeight ) ) +
  geom_point( size = 3 )
```
find the linear regression line the best fits the distribution
```{r}
mod <- lm( childHeight ~ midparentHeight, GaltonFamilies )
coef( mod )
```
```{r}
ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" )
```
Let's add the line that describes a relation where parents have children the same height as they are...
```{r}
ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" ) +
  geom_line( aes( y = midparentHeight ), color = 'red' )
```

Now suppose children height is fully correlated to thier parents. We can use the following equation:
$$\frac{y-\bar{y}}{SD_y} = r\frac{x-\bar{x}}{SD_x}$$
where the correlation, $r = 1$ to find the coefficients of a line describing this:
```{r}
beta <- with( GaltonFamilies,
                sd( childHeight )/ sd( midparentHeight ) )
alpha <- with( GaltonFamilies,
               mean( childHeight ) - 
                 beta * mean( midparentHeight ) )

ggplot(GaltonFamilies, aes(x = midparentHeight, y = childHeight)) + 
  geom_point() +
  geom_smooth( method = "lm" ) +
  geom_line( aes( y = midparentHeight ), color = 'red' ) +
  geom_abline(data=GaltonFamilies, aes(slope=beta, intercept=alpha ), color='green' )
```

**Regression to the Mean**: We can see that a child of tall parents is predicted by the least squares line to have a height which is above average but not quite as tall as the parents as
the green line would have you believe. Similarly children of below average height parents are predicted to have a height which is still below average but not quite as short as the parents. This is why Galton used the phrase “regression to mediocrity” and the phenomenon is sometimes called the regression effect.

### Recommended Exercises:
**1.1** The dataset `teengamb` concerns a study of teenage gambling in Britain. Make a numerical and graphical summary of the data, commenting on any features that you find interesting. Limit the output you present to a quantity that a busy reader would find sufficient to get a basic understanding of the data.

The `teengamb` dataset:
```{r}
data( teengamb )
glimpse( teengamb )
```
```{r}
teengamb_clean <- teengamb %>%
  mutate( sex = factor( sex ),
          status = factor( status ) )
summary( teengamb_clean )
```
The numerical summary shows the distribution of subjects in each group for the categorical variables `sex` and `status` as well as the mode/spread of the numerical features: `income` (lbs/wk), `verbal`, and `gamble` (annual).

and now to visualize the data:
```{r}
#visulize the numeric features by group features
si <- ggplot( teengamb_clean, aes( x = sex, y = income, fill = sex ) ) +
  geom_boxplot()
sv <- ggplot( teengamb_clean, aes( x = sex, y = verbal, fill = sex ) ) +
  geom_boxplot()
sg <- ggplot( teengamb_clean, aes( x = sex, y = gamble, fill = sex ) ) +
  geom_boxplot()

grid.arrange( si, sv, sg, ncol = 3 )

sti <- ggplot( teengamb_clean, aes( x = status, y = income, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")
stv <- ggplot( teengamb_clean, aes( x = status, y = verbal, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")
stg <- ggplot( teengamb_clean, aes( x = status, y = gamble, fill = status ) ) +
  geom_boxplot() + theme(legend.position = "none")

grid.arrange( sti, stv, stg, ncol = 3 )
```
For `sex`, both genders have a very similar distribution of `income` and `verbal` scores. However, one gender has a very different distribution for the annual gambling expenditure.

There appears to be a linear relationship between `verbal` scores and `status` although for other features, the relationship is less clear. However, without knowing the meaning behind the `status` designations, it is difficult to tell.

Look at how some variable covary:
```{r}
ggplot( teengamb_clean, aes( y = gamble, x = income, color = sex ) ) + geom_point( size = 3 ) +
  geom_smooth(method = "lm", alpha = .15, aes(fill = sex))
```
If we plot the amount gambled against weekly income we see two very different trends for the different genders. Males (0) increase their gambling as a function of their weekly income whereas females (1), do not tend to gamble nor show the trend of increasing gambling with increasing income.

Let's take a look at the coefficients for these regression lines:
```{r}
teengamb_clean %>% group_by( sex ) %>%
  do( gambling = broom::tidy( lm( gamble ~ income, data = .))) %>% 
  unnest( gambling )
```
for every GBP increase in weekly income, a male British teen gambles 6.5GBP more annually. However, there is only a negligible increase for females of 0.17.


**1.3** The dataset `prostate` is from a study on 97 men with prostate cancer who were due to receive a radical prostatectomy. Make a numerical and graphical summary of the data as in the first question.

```{r}
data( prostate, package = 'faraway' )
glimpse( prostate )
```
let's learn what the variables are before proceeding:  

* lcavol -> log(cancer volume)
* lweight -> log(prostate weight)
* age -> age (years)
* lbph -> log(benign prostatic hyperplasia amount)
* svi -> seminal vesicle invasion
* lcp -> log(capsular penetration)
* gleason -> Gleason score
* pgg45 -> percentage Gleason scores 4 or 5
* lpsa -> log(prostate specific antigen)

observe summaries of each feature:
```{r}
# svi appears to be binary, so make that adjust:
prostate_clean <- prostate %>%
  mutate( svi = factor( svi ) )
summary( prostate_clean )
```
generate a matrix plot ordered by degree of correlation:
```{r}
dta <- prostate_clean %>%
  select( -c( svi, gleason ) )
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```
we observe a number of cross-correlations that might need attention for further analysis. For example, `lbph`, or the amount of benign prostatic hyperplasia amount is highly correlated with the weight of the prostate, `lweight`.

the Gleason Score assesses the severity of prostate cancer: A Gleason score of 6 is low grade, 7 is intermediate grade, and a score of 8 to 10 is high grade cancer.

We might be interested in using these features to find out what is predictive of `gleason`. How predictive are certain data features correlate with the Gleason Score?

**1.4** The dataset `sat` comes from a study entitled “Getting What You Pay For: The Debate Over Equity in Public School Expenditures.” Make a numerical and graphical summary of the data as in the first question.

```{r}
data( sat )
glimpse( sat )
```
observe the general properties of each variable
```{r}
summary( sat )
```
generate a matrix plot ordered by degree of correlation:
```{r}
dta <- sat
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```

Plot the trends for sat scores as a function of expenditure:
```{r}
sat_scores <- sat %>%
  select( expend, verbal, math ) %>%
  pivot_longer( cols = c( verbal, math ), 
                names_to = 'testcat',
                values_to = 'score' )
ggplot( sat_scores, aes( x = expend, y = score, color = testcat ) ) +
  geom_point( size = 2 ) +
  ylab( 'score' )
```
This plot suggests that there is a negative relationship between the expenditures of a state and the average sat scores for both math and verbal.

```{r}
sat_scores %>% group_by( testcat ) %>%
  do( exscor = broom::tidy( lm( score ~ expend, data = .))) %>% 
  unnest( exscor )
```

look at the cummulative scores
```{r}
sat_total_lm <- sat %>%
  do( totalsat = broom::tidy( lm( total ~ expend, data = . ) ) ) %>%
  unnest( totalsat )
sat_total_lm
```
Although the negative relationship is significant, this does not take into account an important confounding variable: the percentage of students that takes the exam:

```{r}
ggplot( sat, aes( y = total, x = takers ) ) +
  geom_point( size = 2 )
```
Perform a multiple linear regression that includes the percentage of people taking the sat
```{r}
satmod <- lm( total ~ expend + takers, sat )
summary( satmod )
```
There is a dramatic improvement in the model fit when percentage of sat test takers is included. However, there is definitely room for improving on this model. For instance, the 'U' shaped envelope of the relationship between total score and percent test takers hints at a nonlinearity. Additionally, there are more data features in the set that could be explored.

**1.5** The dataset 'divusa' contains data on divorces in the United States from 1920 to 1996. Make a numerical and graphical summary of the data as in the first question.

```{r}
data( divusa )
glimpse( divusa )
```
inspect the summary stats:
```{r}
summary( divusa )
```
Use `facet_wrap()` to look at how each of the features varies with time (`year`):
```{r}
divusa_long <- divusa %>%
  pivot_longer( cols = c( divorce, unemployed, femlab, marriage, birth, military ), names_to = 'cat', values_to = 'val' )
ggplot( aes( x = year, y = val ), data = divusa_long ) +
  geom_line() +
  #geom_point() +
  facet_wrap( ~ cat )
```
There are a few trends we see that occur over time:  

* the increase in percentage of women in the workplace
* spikes in military/femlab/divorce/marriage coinciding with WW2
* a peak in unemployment corresponding with the great depression

and now to view pairwise comparisons:
```{r}
dta <- divusa
dta.r <- abs(cor(dta)) # get correlations
dta.col <- dmat.color(dta.r) # get colors
# reorder variables so those with highest correlation
# are closest to the diagonal
dta.o <- order.single(dta.r)
cpairs(dta, dta.o, panel.colors=dta.col, gap=.5,
main="Matrix plot of features" )
```
There are several relationships that look interesting to explore further:  

* the percentage of women in the workplace has a positive correlation with the divorce rate and a negative relationship with the marriage rate.
* the birth rate has a similar relationship: positively correlated with marriage and negatively correlated to divorce
* Not immediately clear from the previous figure: we see that divorce has a positive correlation with time whereas marriage is negative

## Estimation

### Linear Model
suppose we want to model a response property $Y$ by three feature variables $X_1$ $X_2$ and $X_3$. A general form to represent that is given:
$$Y = f(X_1,X_2,X_3) + \epsilon$$
typically, we won't ever know the true $f$. For linear models, we make the assumption that parameters enter linearly to predict the response:
$$Y = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_3 + \epsilon$$
Linear models seem restrictive, but predictors can be transformed and combined such that linear models can be applied. Linear model implies simplicity, however, in practice linear models and the data they describe may in fact be quite complex.  
Where do linear models come from?  

* Physical Theory may suggest a model (Hooke's Law)
* Experience with past data
* No prior data exists (linear model used as a starting point)

*A good model is like a map that guides us to our destination*

### Estimating \beta
We would like to choose $\beta$ such that the systematic component of our model explains as much of the response as possible. where:

| Data =        | Systemic Structure | + | Random Variation |
|---------------|--------------------|---|------------------|
| n dimentions= | p dimensions       | + | (n-p) dimensions |

The difference between the actual response and the predicted response = the residual. 
The conceptual purpose of the linear model is to represent as accurately as possible, some data that is complex with n-dimensions with something that is comparatively simple, a model with just 'p' terms/coefficients.

### Least Squares Estimation
The random variation in the residuals lies in the n-p dimensional space; the aim of fitting a model is the minimize the residuals.  
n-p = *degrees of freedom*  
RSS = Residual Sum of Squares  
estimate of $\sigma^2$: $\hat{\sigma}^2 = \frac{RSS}{n-p}$

### An Example from the Galapagos
```{r}
data( gala )
glimpse( gala )
```
fit a linear model using `lm()`
```{r}
gala_mod <- lm( Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data = gala )
gala_mod_sum <- summary( gala_mod )
gala_mod_sum 
```
the abridged output alternative from the `faraway` library:
```{r}
sumary( gala_mod )
```

Let's directly calculate some quantities of interest:
```{r}
#extract the feature matrix and the response variable:
fmat <- model.matrix( ~ Area + Elevation + Nearest + Scruz + Adjacent, gala )
r <- gala$Species
```
construct $(X^TX)^{-1}$:
```{r}
xtxi <- solve( t( fmat ) %*% fmat )
```
get $\hat{\beta}$ by calculating $(X^TX)^{-1}X^Ty$:
```{r}
xtxi %*% t( fmat ) %*% r
```
A more efficient and accurate way to get $\hat{\beta}$:
```{r}
solve( crossprod( fmat, fmat ), crossprod( fmat, r ) )
```
compare with the `lm()` results:
```{r}
sumary( gala_mod )
```
We can extract a lot of information from the lm structure:
```{r}
residuals( gala_mod ) #extract the residuals
fitted( gala_mod ) #extract the model predictions
df.residual( gala_mod ) #extract the degrees of freedom
deviance( gala_mod ) #gives the RSS
coef( gala_mod ) #returns the coefficient estimates
```

estimate $\sigma$:
```{r}
sqrt( deviance( gala_mod ) / df.residual( gala_mod ) )
gala_mod_sum$sigma
```
compute the standard error for the coefficients
```{r}
xtxi <- gala_mod_sum$cov.unscaled
SE <- sqrt( diag( xtxi ) ) * gala_mod_sum$sigma
SE
```
or extract the SE
```{r}
gala_mod_sum$coef[,2]
```
There are great reasons to use Least Squares:  

* It makes sense geometrically (makes an orthogonal projection onto model space)
* If the errors are independent and identically normally distributed, it estimates the maximum likelihood
* The Gause-Markov rule states that $\hat{\beta}$ is the best linear unbiased estimate

However, there are some situations where Least Squares might not be the best:

* When errors are correlated of have unequal variance
* When the error distribution is long-tailed
* When the predictors are collinear

### Goodness of Fit
a measure of how well the model fits the data.  
*$R^2$* or the **coefficient of determination** or the **percentage of variance explained**:
$$R^2 = 1 - \frac{\mbox{RSS}}{\mbox{Total SS(Corrected for Mean)}} = \mbox{cor}^2 (\hat{y},y)$$
It is a mistake to rely on $R^2$ as the sole measure of goodness of fit.
```{r}
op <- par(mfrow=c(1,4),mar=c (0,0,2,3), oma = c(5, 4.2, 0, 0))
with(anscombe, plot(x1, y1, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x1, y1),2)))))); abline(3,0.5) 
with(anscombe, plot(x2, y2, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x2, y2),2)))))); abline(3,0.5) 
with(anscombe, plot(x3, y3, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x3, y3),2)))))); abline(3,0.5) 
with(anscombe, plot(x4, y4, xlab = "", ylab = "", main = bquote(paste(italic(r),
" = ",.(round(cor(x4, y4),2)))))); abline(3,0.5) 
mtext(expression(italic(y[1])),side=1, outer = TRUE, line = 3)
mtext(expression(italic(y[2])),side=2, outer = TRUE, line = 2.6)
mtext("(a)",side=3, at = -42, line = .5)
mtext("(b)",side=3, at = -26, line = .5)
mtext("(c)",side=3, at = -10.3, line = .5)
mtext("(d)",side=3, at = 5.5, line = .5)
par(op)
# }
```
All 4 of these distributions result in the same lm slope with the same $R^2$ value.

$\hat{\sigma}$ is another measure returned by the `lm()` summary that is in the same units as the response variable.

### Identifiability
Unidentifiability will occur when $X$ is not of full rank. e.g. columns that are linear combinations of one another.

### Orthogonality
```{r}
data( odor )
glimpse( odor )
```
compute the covariance:
```{r}
cov( odor[,-1] )
```
```{r}
odor_mod <- lm( odor ~ temp + gas + pack, odor )
summary( odor_mod, cor = T )
```
The Correlation Coefs are 0.  
These feature variables are entirely independent

### Exercises

#### 2.4
The dataset `prostate` comes from a study on 97 men with prostate cancer who were due to receive a radical prostatectomy. Fit a model with lpsa as the response and lcavol as the predictor. Record the residual standard error and the $R^2$ . Now add lweight, svi, lbph, age, lcp, pgg45 and gleason to the model one at a time. For each model record the residual standard error and the $R^2$. Plot the trends in these two statistics.

```{r}
data( prostate, package = 'faraway' )
glimpse( prostate )
```
fit model and keep track of residual standard error and $R^3$:
```{r}
formula <- ''
formulas <- c()
res_std_err <- c()
r_sqrd <- c()
feature_order <- c( 'lcavol', 'lweight', 'svi', 'lbph', 'age', 'lcp', 'pgg45', 'gleason' )
for (i in 1:length( feature_order )) {
  if (i == 1) {
    formula <- paste0('lpsa', " ~ ", feature_order[i] )
  }
  else {
    formula <- paste0(formula, " + ", feature_order[i] )
  }
  mod_sum <-  summary( lm( formula, data = prostate ) )
  res_std_err[[i]] <- mod_sum$sigma
  r_sqrd[[i]] <- mod_sum$r.squared
  #print( formula )
}

mods_df <- data.frame( 'n_terms' = seq( 1,8 ),
                       'sigma' = unlist(res_std_err, recursive = FALSE),
                       'r_sqrd' = unlist(r_sqrd, recursive = FALSE) )
glimpse( mods_df )
```

visualize the trends of the summary statistics:
```{r}
sigma_plot <- ggplot( mods_df, aes( x = n_terms, y = sigma ) ) +
  geom_point(fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_line() +
  xlab( 'Number of features added to lm()' ) +
  ylab( 'sigma' ) +
  theme_classic() 

r_sqrd_plot <- ggplot( mods_df, aes( x = n_terms, y = r_sqrd ) ) +
  geom_point(fill = NA, shape = 21, alpha = 0.5, size = 3 ) +
  geom_line() +
  xlab( 'Number of features added to lm()' ) +
  ylab( 'R^2' ) +
  theme_classic() 

grid.arrange( sigma_plot, r_sqrd_plot, ncol = 2 )
```


#### 2.5
Using the prostate data, plot lpsa against lcavol. Fit the regressions of lpsa on lcavol and lcavol on lpsa. Display both regression lines on the plot. At what point do the two lines intersect?

```{r}
m <- lm(lcavol ~ lpsa, prostate)
m2 <- lm(lpsa ~ lcavol, prostate)

plot1 <- ggplot(prostate, aes(lcavol, lpsa)) +
  geom_point(fill = NA, shape = 21, alpha = 0.5, size = 3) +
  geom_line(aes(x = predict(m), color = "lcavol ~ lpsa")) +
  geom_line(aes(y = predict(m2), color = "lpsa ~ lcavol")) +
  theme_classic() 
plot1
```
find the intersection of the two lines:
```{r}
m_aug <- augment( m )
m2_aug <- augment( m2 )
P3 <- c( m2_aug$lcavol[1], m2_aug$.fitted[1] )
P4 <- c( m2_aug$lcavol[length( m2_aug$lcavol )], m2_aug$.fitted[length( m2_aug$lcavol )] )
P1 <- c( m_aug$.fitted[1], m_aug$lpsa[1] )
P2 <- c( m_aug$.fitted[length( m_aug$lcavol )], m_aug$lpsa[length( m_aug$lcavol )] )
intersect <- line.line.intersection(P1, P2, P3, P4, interior.only = TRUE)
int_df <- data.frame( 'X' = intersect[1], 'Y' = intersect[2] )
int_df
```
visually confirm the intersection
```{r}
coords <- paste( '(', round(int_df$X,2), ',', round(int_df$Y,2), ')' )
plot1 + annotate(geom="point", x=int_df$X, y=int_df$Y,
              color="red") +
  annotate(geom="text", x=2, y=2, label=coords,
              color="red")
  ggtitle( 'intersection of lm() model fits' )
```

<br><br><br>